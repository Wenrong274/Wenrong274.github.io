[{"content":"前言 之前有提到 C# Value Type、Reference Type 的差異，提到 String 是 Reference Type，可是在使用時卻很像 Value Type。\n比較值 Value Type 以 int 為舉例\nint a = 1; int b = a; a = 2; Console.WriteLine(a == b); // 輸出: false b 並沒有隨著 a 改變，看得出 int 是 Value Type。\nstring str1 = \u0026#34;abc\u0026#34;; string str2 = str1; str1 = \u0026#34;def\u0026#34;; Console.WriteLine(str1 == str2); // 輸出: false 修改 str1 卻沒有影響到 str2，所以會覺得 string 也是 Value Type(?)。\n比較地址 使用 object.ReferenceEquals 來比較，假如是 Value Type，則會輸出 false。\nint a = 1; int b = 1; Console.WriteLine(object.ReferenceEquals(a, b)); // 輸出: false int 確實是 Value Type，所以會輸出 false。\nstring str1 = \u0026#34;abc\u0026#34;; string str2 = \u0026#34;abc\u0026#34;; Console.WriteLine(object.ReferenceEquals(str1, str2)); // 輸出: true 比較結果為 true，假如 String 是應該會與 int 的結果一樣會是 false。\n也就是 String 其實是 Reference Type。\nString 為什麼是 Reference Type 這裡面提到兩點\nString 對象，若值相同，則其引用地址相同。\nString 對象，若值不等，則其引用地址不等。\nstring str1 = \u0026#34;abc\u0026#34;; //str1指向記憶體位置 addressA 為 abc string str2 = str1; //str2指向記憶體位置 addressA str1 = \u0026#34;def\u0026#34;; //str1新指向記憶體位置 addressB 為 def Console.WriteLine(str1 == str2); // 輸出: false 結論 String 特點就是具有不可變性（immutable），一旦 new String 在記憶體(managed heap)上為它分配一塊連續記憶體空間，我們將不能以任何方式對這個 String 進行修改。所有對這個 String 進行各項操作而返回的 String，實際上是另一個重新 new 的 String，其本身並不會產生任何變化。\nString 效能如何？ 從上面就可以知道 String 有不可變性，一旦創建了就不能修改值，每次修改 String 都會產生一個新的 String，所以 String 效能比較低。\n所以需要經常性操作 String 可以考慮使用 StringBuilder。\n","permalink":"https://wenrongdev.com/posts/csharpreferencetypestring/","summary":"前言 之前有提到 C# Value Type、Reference Type 的差異，提到 String 是 Reference Type，可是在使用時卻很像 Value Type。 比較值 Value Type 以 int 為舉例 int a = 1; int b =","title":"C# Reference Type String"},{"content":"前言 之前有講到 C# Value Type、Reference Type 的差異，現在來講一下 Class 和 Struct 選擇。\n從上一篇的文章中可以知道 Class 是 Reference type，而 Struct 是 Value type。\n如何選擇 根據在類別和結構之間選擇\n作為經驗規則，架構中大部分的類型應該為類別。 不過，在某些情況下，實值型別的特性會使它更適合使用結構。\n可以知道其實大部分時都是使用 Class，但在某些情況下使用 Struct 會比較適合。\n什麼時候使用 Struct 如果類型的執行個體很小，且通常短期或通常內嵌在其他物件中，請考慮定義結構，而不是類別。\n除非類型具有下列所有特性，否則請「避免」定義結構：\n其以邏輯方式表示單一值，類似於基本類型 (int、double 等)。\n其執行個體大小低於 16 個位元組。\n類型為不可變，\n而且不需要經常進行 Box。\n在所有其他情況下，您應該將類型定義為類別。\n參考連結 一起學 Class and Struct (C#)\n","permalink":"https://wenrongdev.com/posts/csharpclassandstruct/","summary":"前言 之前有講到 C# Value Type、Reference Type 的差異，現在來講一下 Class 和 Struct 選擇。 從上一篇的文章中可以知道 Class 是 Reference type，而 Struct 是 Value type。 如","title":"C# Class 和 Struct 選擇"},{"content":"前言 在公司讀書會與同事討論淺複製與深複製的差異和使用時機時，聊到 Reference Type、Value Type 的不同，但是要講淺複製與深複製之前要先講 Reference Type、Value Type 的差異。\nValue Type 有哪些 整數的數字型別：sbyte、byte、short、ushort、int、uint、long、ulong、nint、nuint\n浮點數值型別：float、double、decimal\n內建數值轉換\nbool\nchar\nenum\nstruct\nref struct\ntuples\n可為 Null 的值類型 (C# 參考)\n參考：實值類型 (C# 參考)\nReference Type 有哪些 宣告參考型別：class、interface、delegate、record\n內建參考類型：dynamic、object、string\n可為 Null 的參考型別\n集合和陣列：集合（List、Dictionary）、陣列（int[]、string[]）\n參考：參考型別 (C# 參考)\nValue Type、Reference Type 的差異 根據在類別和結構之間選擇裡的一段話，可以分出 5 點差異。\n1. 存放記憶體 參考型別會配置在回收的堆積和記憶體上，而實值型別則會配置在堆疊上，或內嵌在包含型別上，並在堆疊回溯時或其包含類型解除配置時解除配置。\n因此，實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。\n可以得知主要是在存放的記憶體差異，因此 Value Type 配置和解除配置的成本比 Reference Type 成本更低。\n實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。\n2. 陣列 參考型別的陣列會以換行方式配置，這表示陣列元素只是位於堆積上之參考型別執行個體的參考。實值型別陣列會內嵌配置，這表示陣列元素是實值型別實際的執行個體。\n因此，實值型別陣列的配置和解除配置的成本會遠比參考型別陣列的配置和解除配置的成本來得低。此外，在大部分情況下，實值型別陣列會呈現較佳的參考位置。\nValue Type 陣列的配置和解除配置成本較低，且通常在記憶體存取表現上優於 Reference Type 陣列。然而，Reference Type 陣列在處理複雜的物件或需要物件參考的情境中仍有其必要性。\n3. 記憶體使用量 強制轉型為參考型別或其實作的其中一個介面時，實值型別會進行 Boxed。 當強制轉型回實值型別時，它們會進行 Unboxed。\n因為 Box 是配置在堆積上且被回收記憶體的物件，所以過多 Boxing 和 unboxing 可能會對堆積、記憶體回收行程，以及最終是應用程式的效能造成負面影響。\n強制轉型為 Reference Type 時，Value Type 會進行 Boxed。 當強制轉型回實值型別時會進行 Unboxed，過多的 Boxed 和 Unboxed 會增加垃圾回收（GC）的負擔，從而影響應用程式效能。\n4. 複製參考 參考型別指派會複製參考，而實值型別指派則會複製整個值。 因此，大型參考型別的指派成本比大型實值型別的指派成本更低。\n5. 傳遞方式 參考型別會以傳址方式傳遞，而實值型別則是以傳值方式傳遞。對參考型別的執行個體所做的變更會影響所有指向執行個體的參考。實值型別執行個體會在以傳值方式傳遞時複製。變更實值型別的執行個體時，它必然不會影響其任何複本。\n由於不會由使用者明確建立複本，而是會在傳回引數或傳回值時隱含建立，因此可以變更的實值型別可能會對許多使用者造成混淆。 因此，實值型別應該為不可變。\n由於 Value Type 在傳遞過程中會複製，變更複本時不會影響原始值，這有時會讓使用者感到困惑，因為預期的變更並未反映在原始變數上。\n為了避免這種混淆，Value Type 通常應設計為不可變（immutable）。不可變的 Value Type 一旦創建，其狀態就無法改變，這樣可以確保每個複本都是一致且獨立的。\nReference Type 傳遞物件的記憶體地址。因此，對該物件所做的變更會影響所有持有該物件地址的參考。\n當 Reference Type 的物件進行變更時，因為所有指向該物件的參考都是同一個實例，所有持有該參考的變數都會受到變更影響。\nValue Type 會複製該值並將複本傳遞給目標位置。因此，對複本的變更不會影響原始值。\n當傳遞 Value Type 並對其進行變更時，因為是對複本進行操作，原始實例不會受到任何影響。這意味著每個複本都是獨立的。\n參考連結 一起學 Class and Struct\n","permalink":"https://wenrongdev.com/posts/csharpvaluetypereferencetype/","summary":"前言 在公司讀書會與同事討論淺複製與深複製的差異和使用時機時，聊到 Reference Type、Value Type 的不同，但是要講淺複製與深複製之前要先講 Reference Type、","title":"C# Value Type、Reference Type 的差異"},{"content":"前言 這篇主要是在講虛擬代理人的實作部分。\n實作的主題的方向是讀取中央氣象署的氣象資訊。利用中央氣象署的 API 呼叫後，取得氣象資訊，並且在等待回應時實作虛擬代理設計。\nUML \u0026amp; Build WeatherProxy 使用 weather is null 判斷是否成功取得資料，並且 weatherDataTask == null || weatherDataTask.Status != TaskStatus.Running 來防止重複取得資料。\npublic string GetWeather(string area) { if (weather != null) { return weather.GetWeather(area); } else { if (weatherDataTask == null|| weatherDataTask.Status != TaskStatus.Running) { weatherDataTask = Task.Run(FetchWeatherData); } return \u0026#34;天氣資料更新中...\\n\u0026#34;; } } 完整程式碼\npublic class WeatherProxy : IWeather { /// \u0026lt;summary\u0026gt; /// https://opendata.cwa.gov.tw /// https://opendata.cwa.gov.tw/dist/opendata-swagger.html /// \u0026lt;/summary\u0026gt; private const string Url = \u0026#34;https://opendata.cwa.gov.tw/api/v1/rest/datastore/F-D0047-073\u0026#34;; private const string AuthorizationKey = \u0026#34;AuthorizationKey\u0026#34;; private const string Format = \u0026#34;JSON\u0026#34;; private IWeather weather; private Task weatherDataTask; public string GetWeather(string area) { if (weather != null) { return weather.GetWeather(area); } else { if (weatherDataTask == null|| weatherDataTask.Status != TaskStatus.Running) { weatherDataTask = Task.Run(FetchWeatherData); } return \u0026#34;天氣資料更新中...\\n\u0026#34;; } } private async Task FetchWeatherData() { weather = new Weather(await SendRequest()); } private async Task\u0026lt;Root\u0026gt; SendRequest() { using var client = new HttpClient(); var query = HttpUtility.ParseQueryString(string.Empty); query[\u0026#34;Authorization\u0026#34;] = AuthorizationKey; query[\u0026#34;format\u0026#34;] = Format; var builder = new UriBuilder(Url); builder.Query = query.ToString(); string requestUri = builder.ToString(); string responseJson = await client.GetStringAsync(requestUri); return string.IsNullOrEmpty(responseJson) ? null : JsonSerializer.Deserialize\u0026lt;Root\u0026gt;(responseJson); } } GitHub ","permalink":"https://wenrongdev.com/posts/designpattern-virtualproxy/","summary":"前言 這篇主要是在講虛擬代理人的實作部分。 實作的主題的方向是讀取中央氣象署的氣象資訊。利用中央氣象署的 API 呼叫後，取得氣象資訊，並且在等待回應時","title":"心得 虛擬代理模式"},{"content":"前言 主要是用來解決大部與後端同步資料的方法，在實作方面代理人模式是最常見的解決方案。\n討論 Q1 代理人模式實作方向問題 多人連線後與後端資料同步\n不過確實在實作主題選擇有限，尤其遠端代理需要與後端同步資料，在目前公司遊戲的架構是不需要這樣做的。\nQ2 需要與後端同步記憶體資料嗎？ 不一定，Java RMI、C# WCF、Android AIDL 可以做到同步記憶體資料。\n","permalink":"https://wenrongdev.com/posts/designpattern-proxy/","summary":"前言 主要是用來解決大部與後端同步資料的方法，在實作方面代理人模式是最常見的解決方案。 討論 Q1 代理人模式實作方向問題 多人連線後與後端資料同步 不過","title":"心得 代理人模式"},{"content":"前言 狀態模式主要用來解決多個 if else 判斷，並且不會因為多了一個 if，導致很多方法都要重新寫判斷。\n討論 我提出的問題是狀態模式是由狀態(State) 來控制前往哪個 State，為什麼不是狀態機(Context)來去控制 State 流程。\nState 控制 State 切換 優點：控制流程可以簡化 if else 的判斷，因為在 State 會少很多判斷。\n缺點：也因為在 State 裡面判斷，在 Context 是無法知道什麼時候切換 State。\nContext 控制 State 切換 優點：可以明確的知道切換時機，並且也知道切換的 State。\n缺點：在 Context 切換 State 會有較多的 if else 判斷。\n結論 結論策略模式(Strategy Pattern)與狀態模式的差異，有同事提出是 State 控制 State 切換。假如由 Context 控制 State 切換，就跟策略模式類似。\n我後來想想也有點道理，Context 控制 State 切換並沒有解決多個 if else 判斷，且與策略模式類似。\n","permalink":"https://wenrongdev.com/posts/designpattern-state/","summary":"前言 狀態模式主要用來解決多個 if else 判斷，並且不會因為多了一個 if，導致很多方法都要重新寫判斷。 討論 我提出的問題是狀態模式是由狀態(State)","title":"心得 狀態模式"},{"content":"前言 組合模式是需要 Leaf（子節點）的嗎？\n這是我提出來的問題，因為我覺得 Composite，同時也繼承了 Component，這樣跟 Leaf 也有繼承 Component 差不多。\n後來我覺得也許拆開是為了職責問題，Composite、Leaf 實現功能可能不一樣。\n我後來也參考了別人的定義，其中 Composite、Leaf 的定義有明確職責。\nComponent: 是一個抽象類別，組合模式中的物件都繼承此類別。其中， inflate() 是每一個物件都要實作的功能。 add(Component) 以及 remove(Component) 都是提供給 Composite 類別組合 Leaf 使用的。 Leaf : 是一個具象類別 (Concrete class)，實作 Component 所定義的 inflate()方法，為一個最小單位的物件，在這裏不能包含其他 Leaf 。 Composite ：同樣也是一個具象類別 (Concrete class)，除了實作 Component 定義的 inflate() 方法。將多個 Leaf 紀錄在一個列表 components 裡利用 add(Component) 以及 remove(Component) 來對列表做處理。 結論 讀完這章節後，在我的個人是沒想到自己能使用的環境，可能使用環境是偏像資料搜尋、物件搜尋等。\n","permalink":"https://wenrongdev.com/posts/designpattern-composite/","summary":"前言 組合模式是需要 Leaf（子節點）的嗎？ 這是我提出來的問題，因為我覺得 Composite，同時也繼承了 Component，這樣跟 Leaf 也有繼承","title":"心得 組合模式"},{"content":"IEnumerator、IEnumerable 使用 for、foreach 的差別 Q：實作發現 IEnumerable 能使用 foreach、不能使用 for，IEnumerator 能使用 for、不能使用 foreach，這是為什麼。\nA：IEnumerator 是無法使用 for，foreach 就是跑迭代器。需要有 index 的概念建議使用 for。\nAforeach 裡面的 List 陣列有改變的話，會出現錯誤。\nC# 迭代器延遲執行 A：使用 LinQ 時需要注意到延遲執行的部分。\n是否能夠使用迭代器製作 C# List A：可以，可是想自己寫 yield return 是無法的這是 C# 內建的。\nC# 底層都有繼承 IEnumerable 那是否不需要迭代器模式了？ A：實作不太可能，因為會為了做而做，除非是這個類別很特別才需要。\nUnity 使用 for、foreach 的效能，使用 foreach 會比較耗效能嗎？ A：這是 Unity 舊版 bug。一般用法還好除非是在 Update 使用 foreach 才會有明顯的差異。\nA：因為 Unity C# 與 MS C# 不太一樣，在使用 Unity 物件時不要使用 ?. 的方式。\nNull 條件運算子 ?. 和 ?[]\nA?.B(); 更理解迭代器運作方式 可以先理解 LinQ 運作方式，就可以知道內部迭代跟外部的差異。\n再來可以理解 C# IEnumerator、IEnumerable，要搭配 for、foreach，並且搭配 yield return，就可以理解 yield return 在迭代器的概念。\n最後實作 Unity 協成(Coroutine)，寫一個方法 to IEnumerator 並且使用 StarCoroutine，並且不使用 UnityEngine。\nIEnumerable 在方法上使用是什麼情況會使用到？ A：延遲執行，可以在需要使用的時候再呼叫就可。\nQ：假如不懂的話是不是會是一個坑？\nA：非同步執行或感受非同步執行時使用。希望執行這行程式的時候，不要卡死在這邊，延遲執行可以等資料匯入後再執行。不懂的人使用確實會是一個坑。\n","permalink":"https://wenrongdev.com/posts/designpattern-iterator/","summary":"IEnumerator、IEnumerable 使用 for、foreach 的差別 Q：實作發現 IEnumerable 能使用 foreach、不能使用 for，IEnum","title":"心得 迭代器模式"},{"content":"前言 模板模式最基礎的概念就是需要一個骨架(abstract class)，利用不同方法或流程來實作，算是很常見的設計模式之一。\n模板模式的骨架可搭配泛型使用，可是不能說使用泛型就是模板模式，主要還是要符合骨架、有不同的方法或流程，這幾個要點來區分。\n掛勾 掛勾的部分，主要利用掛勾來實現方法職責，讓模板模式彈性更多一些。在模板模式中掛勾主要是用來判斷流程走向。\n模板模式 vs 策略模式 策略模式主要是針對行為來制定，而模板模式使用相同的骨架，實作不同的內容、流程。\n差異會在有沒有相同骨架、流程，在這部分則不是策略模式的重點。\n策略模式主軸是利用抽換不同的介面達到功能效果。\n好萊塢守則 vs 依賴反轉 好萊塢守則 只是思想，即「不要打電話給我們，我們會打給你」。相較於高階模組、低階模組，就沒有強制規定要不要符合，所以才是一種思想而不是一個設計概念。\n依賴反轉原則 高階模組不應該依賴於低階模組，兩者都應該依賴於抽象介面。\n抽象介面不應該依賴於具體實現。而具體實現則應該依賴於抽象介面。\n依賴反轉原則確實符合好萊塢守則的概念。\n","permalink":"https://wenrongdev.com/posts/designpattern-template/","summary":"前言 模板模式最基礎的概念就是需要一個骨架(abstract class)，利用不同方法或流程來實作，算是很常見的設計模式之一。 模板模式的骨架可","title":"心得 模板模式"},{"content":"前言 當本身有所有使用到類別，就不必使用表象模式。也就是表象模式是需要有各種次系統組裝而成的模式，而不是覺得這邊很複雜就用表象模式。\n表象模式所有的次系統，必須要傳遞進來的物件，自己不能夠封裝類別。\n表象模式不建議使用抽象(interface、abstract)，除非真的知道功能需求。\n表象模式傳遞進來的次系統，不一定需要是介面，也可以傳遞實體物件。\n觀念 封裝成方法跟使用表象模式的差異 特性 表象模式 封裝成方法 目的 簡化介面 提高模組化和可重用性 應用範圍 複雜的系統 任何程式碼 實現方式 使用介面類別來封裝系統 使用方法來封裝邏輯 表象模式和封裝成方法都是有用的設計模式。表象模式可以用於簡化複雜系統的介面，而封裝成方法可以用於提高程式碼的模組化和可重用性。兩者可以結合使用以獲得更好的效果。\n迪米特守則 要注意迪米特守則，使用過度會讓 code 過多，理解難度增加，不必須要為了符合守則而寫出奇怪的設計。\n","permalink":"https://wenrongdev.com/posts/designpattern-facade/","summary":"前言 當本身有所有使用到類別，就不必使用表象模式。也就是表象模式是需要有各種次系統組裝而成的模式，而不是覺得這邊很複雜就用表象模式。 表象模式所","title":"心得 表象模式"},{"content":"主要是用來打包程式輸出成 .msi 檔（Windows Installer）。\n建議先看完 「30 天 | C# WixToolset + WPF 帥到不行的安裝包 系列」，能夠把 80% 以上的問題解決。\n輸出 Wix 文件方法 先到 WiX Toolset Release 安裝需要的工具。\n需要開啟 CMD 且必須要用工作管理員權限打開，之後 cd 到 WiX Toolset 的安裝資料夾。\nC:\\Program Files (x86)\\WiX Toolset v3.11\\bin heat.exe 可以掃描目錄中的所有文件和子目錄，並生成 WiX 文件中所需的 Component、Directory、File 和其他元素的定義。\n使用下面的參數可以拿到 myKeyIn.wxs。需要把 [MyDemo] 替換成正確的路徑，可以參考我的 Product.wxs。\nheat.exe dir \u0026#34;[PUT_YOUR_PATH]\u0026#34; -dr INSTALLFOLDER -cg ProductComponents -gg -gl -sf -srd -var \u0026#34;[MyDemo]\u0026#34; -out \u0026#34;[PUT_YOUR_OUTPUT_PATH]\\myKeyIn.wxs\u0026#34; 參數名稱 解釋 [PUT_YOUR_PATH] 需要打包的路徑資料夾 [MyDemo] WiX 文件中要使用的變數 [PUT_YOUR_OUTPUT_PATH] WiX 文件的路徑 Wix Product.wxs Product.wxs\n桌面捷徑 需要注意一些細項設定，如 Guid、執行檔名稱、路徑等。\n\u0026lt;Directory Id=\u0026#34;DesktopFolder\u0026#34; Name=\u0026#34;Desktop\u0026#34; \u0026gt; \u0026lt;Component Id=\u0026#34;DesktopFolderShortcut\u0026#34; Guid=\u0026#34;{94D38478-869E-4CA8-BEA6-7905A7135DB8}\u0026#34;\u0026gt; \u0026lt;Shortcut Id=\u0026#34;DesktopShortcut\u0026#34; Directory=\u0026#34;DesktopFolder\u0026#34; Name=\u0026#34;Wix-Hello Unity\u0026#34; Target=\u0026#34;[INSTALLFOLDER]Wix-Hello Unity.exe\u0026#34; WorkingDirectory=\u0026#34;INSTALLFOLDER\u0026#34; Icon=\u0026#34;WixToolsetIcon\u0026#34;\u0026gt; \u0026lt;/Shortcut\u0026gt; \u0026lt;RegistryValue Root=\u0026#34;HKCU\u0026#34; Key=\u0026#34;Software\\WenRongStudio\\Wix-Hello Unity\u0026#34; Name=\u0026#34;installed\u0026#34; Type=\u0026#34;integer\u0026#34; Value=\u0026#34;1\u0026#34; KeyPath=\u0026#34;yes\u0026#34;/\u0026gt; \u0026lt;/Component\u0026gt; \u0026lt;/Directory\u0026gt; 資料夾權限 避免安裝在系統槽時，無法變動檔案，所以必須把資料夾權限打開。\n需要注意一些細項設定，如 Guid 等。\n\u0026lt;Component Id=\u0026#34;InstallationDirectory\u0026#34; Guid=\u0026#39;{0D92D4B6-CACE-4556-8CBD-C8C385B22D28}\u0026#39; \u0026gt; \u0026lt;CreateFolder Directory=\u0026#34;INSTALLFOLDER\u0026#34;\u0026gt; \u0026lt;Permission User=\u0026#34;SYSTEM\u0026#34; GenericAll=\u0026#34;yes\u0026#34;/\u0026gt; \u0026lt;Permission User=\u0026#34;EveryOne\u0026#34; GenericAll=\u0026#34;yes\u0026#34; GenericRead=\u0026#34;yes\u0026#34; Read=\u0026#34;yes\u0026#34; ReadAttributes=\u0026#34;yes\u0026#34; GenericExecute=\u0026#34;yes\u0026#34; TakeOwnership =\u0026#34;yes\u0026#34; GenericWrite =\u0026#34;yes\u0026#34; WriteAttributes=\u0026#34;yes\u0026#34; ReadPermission =\u0026#34;yes\u0026#34; ChangePermission=\u0026#34;yes\u0026#34; /\u0026gt; \u0026lt;Permission User=\u0026#34;Users\u0026#34; Domain=\u0026#34;[LOCAL_MACHINE_NAME]\u0026#34; GenericAll=\u0026#34;yes\u0026#34; GenericRead=\u0026#34;yes\u0026#34; Read=\u0026#34;yes\u0026#34; ReadAttributes=\u0026#34;yes\u0026#34; GenericExecute=\u0026#34;yes\u0026#34; TakeOwnership =\u0026#34;yes\u0026#34; GenericWrite =\u0026#34;yes\u0026#34; WriteAttributes=\u0026#34;yes\u0026#34; ReadPermission =\u0026#34;yes\u0026#34; ChangePermission=\u0026#34;yes\u0026#34;/\u0026gt; \u0026lt;/CreateFolder\u0026gt; \u0026lt;/Component\u0026gt; 建立 Windows Menu 資料 可以 Windows Menu 啟動檔案跟卸載執行檔。\n需要注意一些細項設定，如 Guid、執行檔名稱、路徑等。\n\u0026lt;Directory Id=\u0026#34;ProgramMenuFolder\u0026#34;\u0026gt; \u0026lt;Directory Id=\u0026#34;ApplicationProgramsFolder\u0026#34; Name=\u0026#34;Wix-Hello Unity\u0026#34;\u0026gt; \u0026lt;Component Id=\u0026#34;ApplicationShortcut\u0026#34; Guid=\u0026#34;{9724BE7E-7132-4978-B806-4B0D1B3DE350}\u0026#34;\u0026gt; \u0026lt;Shortcut Id=\u0026#34;ApplicationStartMenuShortcut\u0026#34; Name=\u0026#34;Wix-Hello Unity\u0026#34; Description=\u0026#34;Wix-Hello Unity\u0026#34; Target=\u0026#34;[INSTALLFOLDER]\\Wix-Hello Unity.exe\u0026#34; WorkingDirectory=\u0026#34;APPLICATIONROOTDIRECTORY\u0026#34; Icon=\u0026#34;WixToolsetIcon\u0026#34;/\u0026gt; \u0026lt;Shortcut Id=\u0026#34;UninstallProduct\u0026#34; Name=\u0026#34;Uninstall\u0026#34; Description=\u0026#34;Uninstalls Wix-Hello Unity\u0026#34; Target=\u0026#34;[System64Folder]msiexec.exe\u0026#34; Arguments=\u0026#34;/x [ProductCode]\u0026#34; /\u0026gt; \u0026lt;RemoveFolder Id=\u0026#34;ProgramMenuSubfolder\u0026#34; On=\u0026#34;uninstall\u0026#34;/\u0026gt; \u0026lt;RemoveFolder Id=\u0026#34;ApplicationProgramsFolder\u0026#34; On=\u0026#34;uninstall\u0026#34;/\u0026gt; \u0026lt;RegistryValue Root=\u0026#34;HKCU\u0026#34; Key=\u0026#34;Software\\WenRongStudio\\Wix-Hello Unity\u0026#34; Name=\u0026#34;installed\u0026#34; Type=\u0026#34;integer\u0026#34; Value=\u0026#34;1\u0026#34; KeyPath=\u0026#34;yes\u0026#34;/\u0026gt; \u0026lt;/Component\u0026gt; \u0026lt;/Directory\u0026gt; \u0026lt;/Directory\u0026gt; GitHub 參考文章 用 WiX 制作安装包：创建一个简单的 msi 安装包\n30 天 | C# WixToolset + WPF 帥到不行的安裝包 系列\nCreate an Uninstall Shortcut\nCreate a Shortcut on the Start Menu\nRemoving files when uninstalling WiX\n","permalink":"https://wenrongdev.com/posts/wixexamples/","summary":"主要是用來打包程式輸出成 .msi 檔（Windows Installer）。 建議先看完 「30 天 | C# WixToolset + WPF 帥到不行的安裝包 系列」，能夠把 80% 以上的問題解決","title":"Wix Examples"},{"content":"前言 在 Windwos 環境使用 Unity 輸出 XCode，之後使用 Mac 測試、上傳，出現了錯誤。\nCommand PhaseScriptExecution failed with a nonzero exit code 解決方式 因為專案有使用 Cardboard，且 Unity 是使用 2022，才會出現此問題，之前使用 2021 輸出上架都沒問題。\n我的解決方法是把專案改成在 MacOS 上輸出就能完美解決此問題。\n測試過的方法 有測試過的方法，可是對我這次情況沒有效果。\n升級或安裝 Pod。參考 修改 build phases 開啟 For install builds only。參考 修改 Workspace Setting 的 Build System，在 Xcode 14 無法修改。參考 ","permalink":"https://wenrongdev.com/posts/xcode_command_phasescriptexecution_failed/","summary":"前言 在 Windwos 環境使用 Unity 輸出 XCode，之後使用 Mac 測試、上傳，出現了錯誤。 Command PhaseScriptExecution failed with a nonzero exit code 解決方式 因為專案有使用 Cardboard，且 Unity 是使用 20","title":"Xcode Command PhaseScriptExecution Failed"},{"content":"前言 在 Android 11 以上的版本使用 VideoPlayer 呼叫 Stop(); 時會造成 App Crush。\n官方論壇討論此問題文章。\n錯誤 log Stack trace: Error AndroidRuntime signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 Error AndroidRuntime Cause: null pointer dereference Error AndroidRuntime r0 00000000 r1 00003f06 r2 71303e68 r3 00000002 Error AndroidRuntime r4 0848fed2 r5 e5f9b138 r6 ea0e93e0 r7 00000000 Error AndroidRuntime r8 b5c5bfa8 r9 00000000 r10 b5c5bfe8 r11 00000002 Error AndroidRuntime ip e9e63e58 sp b5c5bf00 lr e9df8263 pc e9d823fa Error AndroidRuntime Error AndroidRuntime backtrace: Error AndroidRuntime #00 pc 000773fa /system/lib/libandroid_runtime.so (BuildId: cb59abe29c72e464af331ce6551ec035) Error AndroidRuntime #01 pc 00000136 [anon:.bss] Error AndroidRuntime Error AndroidRuntime at libandroid_runtime.0x773fa(Native Method) Error AndroidRuntime at [anon:.0x136(Native Method) 解決方式 官方在論壇回覆是建議回去 2020 版，之後會修復。因為我使用的專案不方便降版。\n我解決的方式 VideoPlayer.Pause()，然後生成一個新的 VideoPlayer 物件，原本舊的 VideoPlayer 物件不要關閉物件、不要刪除物件，不然都會造成 App Crush。\n不過最終解決方式還是需要等官方處理結束，可以看這個 bug 什麼時候解決 Issue Tracker。\n","permalink":"https://wenrongdev.com/posts/unity2021-videoplayercrush/","summary":"前言 在 Android 11 以上的版本使用 VideoPlayer 呼叫 Stop(); 時會造成 App Crush。 官方論壇討論此問題文章。 錯誤 log Stack trace: Error AndroidRuntime signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x0 Error AndroidRuntime Cause: null pointer dereference Error AndroidRuntime r0 00000000 r1 00003f06 r2 71303e68 r3","title":"Unity2021 Video Player Crush"},{"content":"前言 此篇是優化原本的 Unity ParticlePath\n簡介 有使用 Job System 優化功能。\n100000 顆粒子使用路徑功能時，SAMSUNG GALAXY S7 在不使用 Job System FPS 約 8-9 FPS，使用後變成 18-20 FPS，PC 版多使用了 Burst 會從 30 FPS 提升至 100 FPS。\n可能因為測試的硬體裝置數據優化有所不同，建議還是實際測試後才決定。\n使用方式 可以先使用 demo 場景測試，必須要打開 IsJob，才會啟動 Job System。\nGitHub ","permalink":"https://wenrongdev.com/posts/particlebezierpath/","summary":"前言 此篇是優化原本的 Unity ParticlePath 簡介 有使用 Job System 優化功能。 100000 顆粒子使用路徑功能時，SAMSUNG GALAXY S7 在不使用 Job System FPS 約 8-9 FPS，使用後變成 18-20 FPS，PC","title":"Unity ParticleBezierPath"},{"content":"前言 這是簡易的 Oculus 功能介紹專案，是我製作 VR 專案以來經常使用到的操作行為，我把這些操作行為歸類起來。\n功能接紹有按鈕、抓取、放置、按壓、等操作行為，目前只要有這些功能就能完整製作 VR 的操作行為。\n配置 需要參考官方文件 Get Started with Oculus in Unity，也可以觀看該專案配置。\n","permalink":"https://wenrongdev.com/posts/oculussample/","summary":"前言 這是簡易的 Oculus 功能介紹專案，是我製作 VR 專案以來經常使用到的操作行為，我把這些操作行為歸類起來。 功能接紹有按鈕、抓取、放置、按壓、等操作行為","title":"Oculus Sample"},{"content":"前言 deep link 可以用網址來當 link id，類似像手機點開 Youtube 網址時，假如裝置內有 Youtube App 就會自動開啟 App，並且切換至該影片內容。而 deep link 也可以用網址來當 link id 達到這樣的效果。\n也可以用來呼叫 app 時，假如該裝置沒有安裝可以直接轉移到 app store 上面讓使用者直接下載該 app。\nAndroid 需要在 AndroidManifest 上寫上 link id，可以根據 Create Deep Links to App Content 參考詳細的設置方式。\nurl 呼叫方式 \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;https\u0026#34; /\u0026gt; \u0026lt;data android:host=\u0026#34;wenrongdev.com\u0026#34; /\u0026gt; \u0026lt;data android:pathPrefix=\u0026#34;/unitydeeplink_2\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; host：網址\npathPrefix：節點\n可以利用這種方式，app 超連結開啟或者網頁輸入 https://wenrongdev.com/posts/unitydeeplink_2/ 時就會自動對應到 App。\n自訂 id \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.BROWSABLE\u0026#34; /\u0026gt; \u0026lt;data android:scheme=\u0026#34;app\u0026#34; /\u0026gt; \u0026lt;data android:host=\u0026#34;wenrongdev\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; 可以利用這種方式，app 超連結開啟或者網頁輸入 app://wenrongdev 時就會自動對應到 App。\niOS Unity 設定 link id 的方式在 Deep linking on iOS 有介紹如何設定，而 Xcode 也能設定，不過建議是在 Unity 中設定非必要不建議額外自己在手動設置，主要是怕輸出時忘記導致功能失效。\nXcode 詳細設定可以參考這邊 IOS Deep linking: URL Scheme vs Universal Links\n這樣設定後就會與 Android 一樣的功能，在瀏覽器輸出該 link id 就會自動對應到 app。\n其他 Github Unity Deep Link -1 ","permalink":"https://wenrongdev.com/posts/unitydeeplink_2/","summary":"前言 deep link 可以用網址來當 link id，類似像手機點開 Youtube 網址時，假如裝置內有 Youtube App 就會自動開啟 App，並且切換至該影片內容。而 deep link 也可以用網址來當 link id 達","title":"Unity Deep Link -2"},{"content":"前言 DeepLink 是可以直接用網址呼叫 App 的方式之一，以前有提到可以利用 Get Android Intent Data for Unity 這邊文章提到的方式，呼叫 App，不過這只限定 Android，iOS 則還是需要用 Deeplink 的方式呼叫。主要是當時 Unity 版本並不支援 DeepLink，所以只能自己寫原生的，才會有之前的這篇文章，更重要的是，使用之前的呼叫方式是需要某些權限，但目前 Google 也把這些權限關閉，無法正常上架需要自己寫信去解釋才會願意讓你正常上架。所以建議是棄用這種方法改用 Deeplink。\n詳細資料 Unity Deep Link\nAndroid Deep Link\niOS Deep Link\n建議是一定要把 Unity Deep Link 看完，才會知道怎麼設定，其餘兩邊則是原生地設定方式，可以參考。\n使用方式 Unity Deep link Doc\n官方也有文件解釋 Deep link 的基礎設定。\nScript Start 需要再被喚醒 app 的瞬間也就是 Awake 時，先讀取 Application.absoluteURL 才能讀取道 deep link 的資料。Application.deepLinkActivated 部分則是 app 的 deep link feedback。\nprivate void Awake() { Application.deepLinkActivated += OnDeepLinkActivated; if (!string.IsNullOrEmpty(Application.absoluteURL)) OnDeepLinkActivated(Application.absoluteURL); } Script Url Arg 拆解 Deep link 夾帶的參數，格式大概與 web 的 url get 類似，可以用這種方式去解析，夾帶的參數。\nprivate void OnDeepLinkActivated(string url) { string[] urlArg = url.Split(\u0026#39;?\u0026#39;); string[] args = new string[0]; if (urlArg.Length \u0026gt; 1) { char[] charSeparators = new char[] { \u0026#39;\u0026amp;\u0026#39; }; args = urlArg[1].Split(charSeparators, StringSplitOptions.RemoveEmptyEntries); } for (int i = 0; i \u0026lt; args.Length; i++) { Debug.Log(args[i]); } } 其他 Github Unity Deep Link -2 ","permalink":"https://wenrongdev.com/posts/unitydeeplink_1/","summary":"前言 DeepLink 是可以直接用網址呼叫 App 的方式之一，以前有提到可以利用 Get Android Intent Data for Unity 這邊文章提到的方式，呼叫 App，不過這只限定 Android，iOS 則還","title":"Unity Deep Link -1"},{"content":"前言 Unity Text 中英混雜導致英文字跳行問題，主要是 Space 字串的問題，可以用 \\u00A0 替代 Space。\nCode private static readonly string no_breaking_space = \u0026#34;\\u00A0\u0026#34;; public static string ReplaceSpace(string context) { return context.Replace(\u0026#34; \u0026#34;, no_breaking_space); } 可以這樣替代全部的 Space。\n範例 使用前 使用後 ","permalink":"https://wenrongdev.com/posts/unitytextbreakingspace/","summary":"前言 Unity Text 中英混雜導致英文字跳行問題，主要是 Space 字串的問題，可以用 \\u00A0 替代 Space。 Code private static readonly string no_breaking_space = \u0026#34;\\u00A0\u0026#34;; public static string ReplaceSpace(string context) { return context.Replace(\u0026#34; \u0026#34;, no_breaking_space); } 可以這樣替代全部的 Sp","title":"Unity Text Breaking Space"},{"content":"前言 之前因為遇到多平台功能，要輸出時各個平台 Player Setting 細項設定皆為不同，會因為某些沒有設定導致輸出時出包，所以才寫了一個自動輸出個平台功能。\nXR Setting 可以利用這段來新增或移除 XR 裡面的 Oculus 勾選。\nprivate static void SetOculusXRLoader(BuildTargetGroup buildTarget, bool active) { XRGeneralSettingsPerBuildTarget buildTargetSettings = null; EditorBuildSettings.TryGetConfigObject(XRGeneralSettings.k_SettingsKey, out buildTargetSettings); XRGeneralSettings settings = buildTargetSettings.SettingsForBuildTarget(buildTarget); if (active) XRPackageMetadataStore.AssignLoader(settings.Manager, \u0026#34;Unity.XR.Oculus.OculusLoader\u0026#34;, buildTarget); else XRPackageMetadataStore.RemoveLoader(settings.Manager, \u0026#34;Unity.XR.Oculus.OculusLoader\u0026#34;, buildTarget); } Build 利用這段自動輸出，options 可以設定 BuildOptions.None、BuildOptions.AutoRunPlayer，一般的 Build 和 Build and Run。\nprivate static void BuildRelease(string Path, BuildTarget Target, BuildOptions options) { Console.Clear(); BuildPlayerOptions playerOptions = GetBuildPlayer(Path, Target, options); BuildReport Report = BuildPipeline.BuildPlayer(playerOptions); EditorUtility.RevealInFinder(Path); Debug.Log(string.Format(\u0026#34;{0} Build completed with a result of \u0026#39;{1}\u0026#39; \u0026#34;, Application.platform, Report.summary.result.ToString())); } private static BuildPlayerOptions GetBuildPlayer(string path, BuildTarget Target, BuildOptions options) { return new BuildPlayerOptions() { scenes = EnabledScenePaths, locationPathName = path, target = Target, options = options }; } 完整 Script public class SampleBuildRelease { private static string AppName =\u0026gt; PlayerSettings.productName; private static string Version =\u0026gt; Application.version.Replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;); private static string BuildFolder { get { return Directory.GetParent(Application.dataPath).FullName.Replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;) + \u0026#34;/Build\u0026#34;; } } private static string[] EnabledScenePaths =\u0026gt; EditorBuildSettings.scenes .Where((scene) =\u0026gt; scene.enabled) .Select((scene) =\u0026gt; scene.path) .ToArray(); [MenuItem(\u0026#34;Builds/Build/Oculus\u0026#34;)] public static void Build_Oculus() { string path = Path.Combine(BuildFolder, \u0026#34;Oculus\u0026#34;, $\u0026#34;Oculus_{AppName}_Ver{Version}.apk\u0026#34;); BuildReleaseOculus(path, BuildOptions.None, true); } [MenuItem(\u0026#34;Builds/Build And Run/Oculus\u0026#34;)] public static void BuildAndRun_Oculus() { string path = Path.Combine(BuildFolder, \u0026#34;Oculus\u0026#34;, $\u0026#34;Oculus_{AppName}_Ver{Version}.apk\u0026#34;); BuildReleaseOculus(path, BuildOptions.AutoRunPlayer, true); } private static void BuildReleaseOculus(string path, BuildOptions buildOptions, bool AddXR) { SetOculusXRLoader(BuildTargetGroup.Android, AddXR); BuildRelease(path, BuildTarget.Android, buildOptions); } [MenuItem(\u0026#34;Builds/Build/Windows\u0026#34;)] public static void Build_Windows() { BuildReleaseWindows(BuildOptions.None); } [MenuItem(\u0026#34;Builds/Build And Run/Windows\u0026#34;)] public static void BuildAndRun_Windows() { BuildReleaseWindows(BuildOptions.AutoRunPlayer); } private static void BuildReleaseWindows(BuildOptions buildOptions) { string folder = Path.Combine(BuildFolder, $\u0026#34;{BuildTarget.StandaloneWindows}\u0026#34;, $\u0026#34;Windows_{AppName}_Ver{Version}\u0026#34;); string path = Path.Combine(folder, $\u0026#34;{AppName}.exe\u0026#34;); SetOculusXRLoader(BuildTargetGroup.Standalone, false); BuildRelease(path, BuildTarget.StandaloneWindows, buildOptions); } private static void SetOculusXRLoader(BuildTargetGroup buildTarget, bool active) { XRGeneralSettingsPerBuildTarget buildTargetSettings = null; EditorBuildSettings.TryGetConfigObject(XRGeneralSettings.k_SettingsKey, out buildTargetSettings); XRGeneralSettings settings = buildTargetSettings.SettingsForBuildTarget(buildTarget); if (active) XRPackageMetadataStore.AssignLoader(settings.Manager, \u0026#34;Unity.XR.Oculus.OculusLoader\u0026#34;, buildTarget); else XRPackageMetadataStore.RemoveLoader(settings.Manager, \u0026#34;Unity.XR.Oculus.OculusLoader\u0026#34;, buildTarget); } private static void BuildRelease(string Path, BuildTarget Target, BuildOptions options) { Console.Clear(); BuildPlayerOptions playerOptions = GetBuildPlayer(Path, Target, options); BuildReport Report = BuildPipeline.BuildPlayer(playerOptions); EditorUtility.RevealInFinder(Path); Debug.Log(string.Format(\u0026#34;{0} Build completed with a result of \u0026#39;{1}\u0026#39; \u0026#34;, Application.platform, Report.summary.result.ToString())); } private static BuildPlayerOptions GetBuildPlayer(string path, BuildTarget Target, BuildOptions options) { return new BuildPlayerOptions() { scenes = EnabledScenePaths, locationPathName = path, target = Target, options = options }; } } ","permalink":"https://wenrongdev.com/posts/oculusautosetbuildsettingandbuild/","summary":"前言 之前因為遇到多平台功能，要輸出時各個平台 Player Setting 細項設定皆為不同，會因為某些沒有設定導致輸出時出包，所以才寫了一個自動輸出個平台功能。 XR Setting 可","title":"Oculus Auto Set Build Setting \u0026\u0026 Build"},{"content":"Unity Project Structure 主要是建立一個自動建立簡易專案資料夾結構。\n此參考 UnityProjectTreeGenerator 方法建立資料夾，\n使用方式 Tools \u0026gt; Generate Project Structure\n必須要設定 Root Name 才能點擊 Create Structure\n資料夾結構 |- Assets |- Project Name /// 自己設定 |- 00_Art | |- 00_Profabs | | |- Models | | |- UI | |- 01_Shaders | | |- UI_Shaders | |- 02_Timeline | |- 03_Models | | |- Example_Model | | | |- 3D | | | |- Animation | | | |- Textures | | |- Example_Effect | | |- Textures | |- 04_Scenes | |- 05_UI | | |- Textures | | |- Effect | | |- Textures | | |- Animation | | |- Material | |- 07_Audio | |- 08_Video |- 01_Program |- 00_Scenes |- 01_Scripts |- 02_Tests |- 03_Prefabs |- 05_UI Github ","permalink":"https://wenrongdev.com/posts/unit-unity-projectstructure/","summary":"Unity Project Structure 主要是建立一個自動建立簡易專案資料夾結構。 此參考 UnityProjectTreeGenerator 方法建立資料夾， 使用方式 Tools \u0026gt; Generate Project Structure 必須要設定 Root Name 才能點擊 Create Structure 資料夾結構 |- Assets |- Project Name /// 自","title":"Unity Project Structure"},{"content":"前言 針對 Unity Shader 檔案打開時，使用 VSCode 開啟而不是 Visual Studio，假如預設是 VSCode 則無需使用這功能。\n會寫這功能是平常寫 C# 都是習慣使用 Visual Studio，而 Visual Studio 好像沒有針對 Unity Shaderlab 的關鍵字，而 VSCode 則有 ShaderlabVSCode(Free)，也因此這樣選擇使用 VSCode。\n因為平常開發時都是使用 Visual Studio，想開啟 Shader 時可以直接使用 VSCode 編輯，因此才參考 Sublime Text \u0026amp; Unity Shader，把 Sublime Text 改成使用 VSCode。\n環境變數 需要注意環境變數裡的使用者變數的 Path 需要有 VSCode 的路徑\n也可以使用 CMD 測試有無環境變數\nVSCode CLI Args 根據 Unity 開啟 VSCode Args，可以使用 Process 填寫對應路徑就可以了。\n\u0026#34;$(ProjectPath)\u0026#34; -g \u0026#34;$(File)\u0026#34;:$(Line):$(Column) startInfo.Arguments = $\u0026#34;{projectPath} -g {fileName}\u0026#34;; Script 詳細的方法可以參考 Sublime Text \u0026amp; Unity Shader。\npublic class OpenShaderForVSCodeEditor { [UnityEditor.Callbacks.OnOpenAsset(0)] public static bool CallbackShader(int instanceID, int line) { string projectPath = Directory.GetParent(Application.dataPath).ToString(); string strFilePath = AssetDatabase.GetAssetPath(EditorUtility.InstanceIDToObject(instanceID)); string fileName = projectPath + \u0026#34;/\u0026#34; + strFilePath; if (fileName.EndsWith(\u0026#34;.shader\u0026#34;)) { var envUser = Environment.GetEnvironmentVariables(EnvironmentVariableTarget.User); var envPaths = envUser[\u0026#34;Path\u0026#34;].ToString().Split(\u0026#34;;\u0026#34;); string vscodePath = string.Empty; for (int i = 0; i \u0026lt; envPaths.Length; i++) { var path = Path.Combine(envPaths[i], \u0026#34;code\u0026#34;); if (File.Exists(path)) { vscodePath = path; break; } } if (!string.IsNullOrEmpty(vscodePath)) { Process process = new Process(); ProcessStartInfo startInfo = new ProcessStartInfo(); startInfo.WindowStyle = ProcessWindowStyle.Hidden; startInfo.FileName = vscodePath; ///vscode args \u0026#34;$(ProjectPath)\u0026#34; -g \u0026#34;$(File)\u0026#34;:$(Line):$(Column) startInfo.Arguments = $\u0026#34;{projectPath} -g {fileName}\u0026#34;; process.StartInfo = startInfo; process.Start(); return true; } else { UnityEngine.Debug.Log(\u0026#34;Not Found Enviroment Variable \u0026#39;VSCode_Path\u0026#39;.\u0026#34;); return false; } } return false; } } GitHub ","permalink":"https://wenrongdev.com/posts/openshaderforvscode/","summary":"前言 針對 Unity Shader 檔案打開時，使用 VSCode 開啟而不是 Visual Studio，假如預設是 VSCode 則無需使用這功能。 會寫這功能是平常寫 C# 都是習慣使用 Visual Studio，而 Visual Studio","title":"Unity Open Shader For VSCode"},{"content":"前言 介紹我使用 Addressable 的讀取、生成、釋放方式。\n詳細設定還是可以先觀看官方文件。\nEvent Viewer 可以利用 Event Viewer 在 Editor Runtime 時，隨時監控記憶體使用情況。就可以很明顯的發現，那些東西是忘記釋放掉的，或者不需要釋放的。\nLoad Asset IEnumerator InstantiateAsset(string asset) { AsyncOperationHandle\u0026lt;GameObject\u0026gt; async = asset.LoadAssetAsync\u0026lt;GameObject\u0026gt;(); yield return async; GameObject go = Instantiate(async.Result); } IEnumerator InstantiateAssets(string label) { AsyncOperationHandle\u0026lt;IList\u0026lt;GameObject\u0026gt;\u0026gt; async = Addressables.LoadAssetsAsync\u0026lt;GameObject\u0026gt;(label, null); yield return async; for (int i = 0; i \u0026lt; async.Result.Count; i++) GameObject go = Instantiate(async.Result[i]); } IEnumerator InstantiateAsset(AssetReference asset) { AsyncOperationHandle\u0026lt;GameObject\u0026gt; async = asset.LoadAssetAsync\u0026lt;GameObject\u0026gt;(); yield return async; GameObject go = Instantiate(async.Result); } 可以利用這三種方式讀取 Asset，並且把物件生成出來，當然我還是最推薦使用 AssetReference，除非有什麼特殊需求要使用字串，不然我不會換成其他方式。\nRelease Asset 釋放掉 Asset 也記得要把物件刪除，不然場上會遺留破圖的物件。\nprivate void ReleaseAsset(AsyncOperationHandle\u0026lt;T\u0026gt; async) { Addressables.Release(async); } private void ReleaseAsset(T asset) { Addressables.Release(asset); } private void ReleaseAsset(AssetReference asset) { asset.ReleaseAsset(); } 可以利用生成的物件或者 Load asset 的 Async 釋放，假如是使用 AssetReference Load Asset，也可以使用這個方式釋放。\n","permalink":"https://wenrongdev.com/posts/unity-addressable_load_assets/","summary":"前言 介紹我使用 Addressable 的讀取、生成、釋放方式。 詳細設定還是可以先觀看官方文件。 Event Viewer 可以利用 Event Viewer 在 Editor Runtime 時，隨時監控記憶體使用情況。就可以很明顯的發現","title":"Unity Addressable Load Assets"},{"content":"前言 在前一篇 Unity Addressable 介紹了簡易使用的方式，此篇是介紹下載 Asset 方法。\n目前我個人使用過的方式有 Name、Label、AssetReference、Array AssetReference 的方式。\nAddressables.LoadAssetAsync 官方範例提供的下載方式 Addressables.LoadAsset(s)Async，雖然這個是要把 Asset 讀取出來，其實他也有下載功能\nAddressables.LoadAssetAsync\u0026lt;GameObject\u0026gt;(asset); 我是很少使用這種方式下載或更新 Asset，主因是我個人認為 Addressables.LoadAssetAsync 是讀取物件而不是更新物件的功能，所以我在需要更新時不會使用它。\nUpdate Addressable Name/ Addressable Label IEnumerator UpdateAsset(string asset) { var downloadAsync = Addressables.DownloadDependenciesAsync(asset, false); yield return downloadAsync; Addressables.Release(downloadAsync); } 這個是下載 Addressable Name 或 Label的方法，可以利用 Label 下載多個不同 Group 的 Asset。\nAddressable Name、Label 是無法利用 Hotfix 的方式產生，所以是要先創好需要的。若假如需要新的 Addressable Name、Label 是必須要重新輸出 App 才會更新。\nUpdate Asset Reference IEnumerator UpdateAsset(AssetReference asset) { var downloadAsync = Addressables.DownloadDependenciesAsync(asset, false); yield return downloadAsync; Addressables.Release(downloadAsync); } AssetReference 的用法是我最推薦的下載方式，可以很明顯的知道更新物件，不會因為打錯文字導致更新失敗，而且也可以利用這個方式組合物件，讓更新的內容比較簡單方式處理。\n例如用一個物件或場景夾帶了多個不同的需要更新的物件，缺點就是這包 pack 輸出會過大，可能需要把每個物件獨立分成多個 AssetReference，利用系統特性夾帶物件變小。不過要是不喜歡這種方式可以看 Update Multiple Asset References。\n不過 AssetReference 最方便還是使用它來生成、釋放、等等，才是最好用的方式。\nUpdate Multiple Asset References IEnumerator DonwloadMultipleAssets(AssetReference[] assets) { var assetKeys = assets.Cast\u0026lt;AssetReference\u0026gt;(); var downloadAsync = Addressables.DownloadDependenciesAsync(assetKeys, Addressables.MergeMode.Union); yield return downloadAsync; Addressables.Release(downloadAsync); } 多個 AssetReference 更新的方式，然後可以一起更新。可以完成一個簡單的多個物件更新，不用利用 Label、整合包、等方式更新。\n取得下載容量大小方法 IEnumerator CheckSizeAsync(string asset) { var async = Addressables.GetDownloadSizeAsync(asset); yield return async; if (async.Status == AsyncOperationStatus.Succeeded) { float size = Mathf.Round((float)async.Result / 1024 / 1024 * 1000) / 1000; Debug.Log($\u0026#34;Total {size} MB\u0026#34;); } Addressables.Release(async); } 更新進度條寫法 IEnumerator UpdateAsset(AssetReference asset) { var downloadAsync = Addressables.DownloadDependenciesAsync(asset, false); while (!downloadAsync.IsDone) { float percent = downloadAsync.PercentComplete; Debug.Log($\u0026#34;{asset}: {downloadAsync.PercentComplete * 100} %\u0026#34;); yield return new WaitForEndOfFrame(); } Addressables.Release(downloadAsync); } ","permalink":"https://wenrongdev.com/posts/unity-addressable_download_assets/","summary":"前言 在前一篇 Unity Addressable 介紹了簡易使用的方式，此篇是介紹下載 Asset 方法。 目前我個人使用過的方式有 Name、Label、AssetReference、Ar","title":"Unity Addressable Download Assets"},{"content":"前言 輸出 Apk 遇到的錯誤\nFix Installed Build Tools revision 3X.0.0 is corrupted. 修改方式 修改 d8.bat 檔案路徑 \u0026lt;Android SDK root\u0026gt;\\build-tools\\3X.0.0\n將 d8.bat 改為 dx.bat。\n修改 d8.jar 檔案路徑 \u0026lt;Android SDK root\u0026gt;\\build-tools\\3X.0.0\\lib\n將 d8.jar 改為 dx.jar。\n就完成修改。\n參考連結 Android Studio error \u0026ldquo;Installed Build Tools revision 31.0.0 is corrupted\u0026rdquo;\n","permalink":"https://wenrongdev.com/posts/unity-android_failed_buildtoolsbug/","summary":"前言 輸出 Apk 遇到的錯誤 Fix Installed Build Tools revision 3X.0.0 is corrupted. 修改方式 修改 d8.bat 檔案路徑 \u0026lt;Android SDK root\u0026gt;\\build-tools\\3X.0.0 將 d8.bat 改為 dx.bat。 修改 d8.jar 檔案路徑 \u0026lt;Android SDK root\u0026gt;\\build-tools\\3X.0.0\\lib 將 d8.jar 改為 dx.jar。 就完成修改。","title":"Android Build Failed Build tools 3X.0.0 Bug"},{"content":"前言 此篇在講如何使用 Hugo 在 Github 上自架 Blog。\n安裝 Hugo 關於安裝的部分可以參考這些文章\nQuick Start GitHub 部署 Hugo 靜態網站 使用 Hugo 建立靜態網站，並部署在 Github Page Hugo 貼身打造個人部落格 系列 與文章不同的地方主題我是選擇 PaperMod，由於需要設定 config.yml，建議先參考 PaperMod-Installation。\n想要完整的設定或理解 PaperMod，最好是完整的看完 PaperMod 的 repo，有不知道的問題可以在 Issues 或者 FAQs 搜尋看看，會比 google 搜尋來得快。\nPaperMod 由於 PaperMod 推薦使用 config.yml，因此推薦把原本的 config.toml 刪除。並且去複製官方提供的 config.yml。\nconfig.yml Search Post 先在 config menu main 新增一個 Search 頁面\nmenu: main: - identifier: archives name: Archives url: /archives/ weight: 5 - identifier: tags name: Tags url: /tags/ weight: 10 - identifier: search name: Search url: /search/ weight: 20 且在最底下此內容。（參考文件）\noutputs: home: - HTML - RSS - JSON # is necessary 最後在專案的 content 底下新增 search.md，即可完成功能。（參考文件）\n--- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; placeholder: \u0026#34;placeholder text in search input box\u0026#34; --- Comments 此功能是參考 Day 20. Hugo Comments System 文章製作出來的。\nGithub Action 有使用 Custom domain 的話，且 workflows 沒有設定 domain 的話，會造成每次更新文章時，都會清掉 Custom domain，變回原本的 github.io。\nGitHub Pages workflow.yml name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.91.2\u0026#34; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.HUGO_DEPLOY_TOKEN }} PUBLISH_BRANCH: gh-pages # 推送到 gh-pages 分支 commit_message: ${{ github.event.head_commit.message }} publish_dir: ./public cname: wenrongdev.com 只需要新增或替換掉 cname 後面為 domain 即可。\n結論 Hugo 或 PaperMod 我都處於摸索階段。\n這次架起來的感覺各方面都不錯，不管是讀取 Blog 速度、支援 Markdown、架設 Github 上且保留原始檔，到目前為止沒有明顯的缺點。\n目前最大問題就是 SEO，這是我完全沒有接觸過的。問題在於 Google 搜尋不到我的 Blog，所以這是之後要研究的部分。\n","permalink":"https://wenrongdev.com/posts/reflection-blog-3/","summary":"前言 此篇在講如何使用 Hugo 在 Github 上自架 Blog。 安裝 Hugo 關於安裝的部分可以參考這些文章 Quick Start GitHub 部署 Hugo 靜態網站 使用 Hugo 建立靜態網站，並部署在 Github Page Hugo 貼身打造","title":"Blog 心得（3）"},{"content":"前言 由於 SiteGround 費用問題，因此我需要把文章轉移至別的地方。不過也知道自己需要哪些功能。\n免費 Server 網頁速度快 支援程式碼片段 自訂網域 這些是我目前需要的功能，不需要排版、SEO、等功能，最好是直接把 Markdown 語法貼上就能變成文章，剩下就都可以接受了。\nMedium 先說結論 Medium 不適合需要貼上 Code 的技術類文章。\n貼程式碼片段太麻煩。\n使用 Markdown 語法撰寫文章，因為格式不同需要重新排版。\n以上這兩點是使用後遇到的難題，導致我不得不再尋找新的平台。也是這時候才知道自己的 Blog 需要什麼樣的功能。最後在 寫技術部落格不需要那麼大費周章 發現了 CoderBridge，並且申請了 Blog。\nCoderBridge 完整提供 前言 提到所有功能，不過我最後還是選擇使用 Hugo 自架 Blog。\n主因是文章沒有備份檔。\n因為我自己的壞習慣，所以才都沒有留住這些檔案。也因為從 Wordpress、Medium、CoderBridge 換了三個 Blog，覺得搬遷好麻煩，都沒有完整的文章檔案，每次都需要重新排版，才會想架一個免費而且可以保留文章檔案的 Blog。\n最後自己是選擇了使用 Hugo 框架架在 Github page 上。\n結論 Wordpress、Medium、CoderBridge 我覺得各有優缺點，假如自己從一開始就決定要找免費的，我會選擇使用 CoderBridge，不過也因為搬來搬去才知道自己需要哪些功能，最後使用 Hugo 也只是因為我自己覺得很潮而已。\n","permalink":"https://wenrongdev.com/posts/reflection-blog-2/","summary":"前言 由於 SiteGround 費用問題，因此我需要把文章轉移至別的地方。不過也知道自己需要哪些功能。 免費 Server 網頁速度快 支援程式碼片段 自訂網域 這些是我目前需要的功能","title":"Blog 心得（2）"},{"content":"其實我的 Blog 是寫給自己看的。因為我時常忘記怎麼解決問題、怎麼製作功能、忘記是做了什麼蠢事。因此產生這個 Blog 用來記錄我的跌跌撞撞的過程。\n前言 在大學寫程式時遇到問題去 Google 查，很多時候很難下關鍵字，主要是自己犯蠢導致很難知道原因。自然而然也很難對症下藥，很多時候只是重打或參考(?)同學就能解決學生時期遇到的問題。\n當開始工作時的第一年內，遇到的問題基本上還是類似的，因為我實在是太菜了，會遇到一些其實很基本又很無言的低級錯誤，一直重複的犯錯麻煩其他同事幫忙 debug，所以我一直有一個念頭想架設自己的 Blog。記錄解決過程和解決方式，提醒未來自己有錯誤可以來這邊看，假如又可以幫助別人其實也不錯。\nBlogger 第一個 Blog 是使用大學某堂課程用到的 Blogger，其實也沒太認真研究這個 Blog，因為覺得不夠好看用了一下沒有認真的使用。\n多年之後看到 搞笑談軟工 的 Blog，才知道 Blog 的重要的部分其實不是選用什麼架構，持續寫作 才是最重要的核心。\nWordpress 2018 時覺得自己的學習成長曲線變慢了，可能是因為都接觸類似的東西，工作上也大部分內容都能應付，也不會像以前一樣回家繼續寫程式，簡單來講就是發現自己進入了舒適圈(?)。就很坎坷不安，於是就開始買書學習、跟人學習。\n2019 的某天 Unity 程式社群，有人發問推薦的程式書籍，而 阿祥的開發日常 的 Ted 回答了 軟技能代碼之外的生存指南。整本書內容都沒在講程式的部分，大部分內容都是在講工程師除了工作以外的事情，例如運動、投資、面試、等等，推薦沒看過的工程師可以買，對於我個人是獲益良多，也是因為看了才有想認真的自己架設 Blog。\n書的內容其實就有推薦架設屬於自己的 Blog，當時看到就想到我當年的想法，是沒有想要跟作者一樣利用 Blog 賺錢，畢竟技術不到家。倒是覺得可以當一個不錯的作品集，於是就開始在架設自己的 Wordpress。\n當時是看著 教學 文章邊看邊選擇，過程除了刷卡付錢沒有什麼難度，我在 NameCheap 買網址，虛擬主機則是使用 SiteGround。\n使用三年心得 (2019~2020) 年分 SiteGround NameCheap 花費(NTD) 第一年 1493 285 1778 第二年 5375 315 5690 第三年 0 368 368 總花費 7836 第一年 1778 元。而且很多功能可以玩、可以使用，整體使用是很滿意的。而到了第二年，沒有認真確認第一年花費多少就直接續約了，收到扣款通知才知道收費真的很貴。\n第一年跟第二年價格差了 3912 元，當時也沒有想到要退款，想說明年扣款時再來處理。\n到了第三年，就打算不續約 SiteGround，所以開始把文章轉移去 Medium，不過 NameCheap 是有持續付費的，畢竟費用還是較少，而且網址現在還在使用。\n後來用 Hugo 架設這個 Blog，才知道 Wordpress 的好，很多事情都很簡單就完成（SEO、theme、等等）。\n結論 整體而言 Wordpress 對於新手的我架設 Blog，確實是不錯的體驗，只要有錢基本都能處理。不過續約的花費太貴，所以才放棄使用 SiteGround，尋找一些免費的方式。\n當時使用 NameCheap 時也有被盜刷過，記得要綁定 2FA、密碼不要重複。 ","permalink":"https://wenrongdev.com/posts/reflection-blog-1/","summary":"其實我的 Blog 是寫給自己看的。因為我時常忘記怎麼解決問題、怎麼製作功能、忘記是做了什麼蠢事。因此產生這個 Blog 用來記錄我的跌跌撞撞的過程。 前言 在大學","title":"Blog 心得（1）"},{"content":"前言 此專案為 Unity math quiz，是基於 Tutorial 2: Create a timed math quiz 文件改寫出來的專案。\nGithub ","permalink":"https://wenrongdev.com/posts/unity-mathquiz/","summary":"此專案為 Unity math quiz，是基於 Tutorial 2 Create a timed math quiz 文件改寫出來的專案。","title":"Unity MathQuiz"},{"content":"前言 使用方式 預設日期為當天日期。\n可以直接使用 UnityCalendar.GetDate() 取得使用者設定日期，假如有錯誤會回報錯誤。\ntestGetDate.cs\npublic void OnClick_GetDate() { DateTime dt = unityCalendar.GetDate(); text.text = dt.ToString(\u0026#34;yyyy-MM-dd\u0026#34;); } public void OnClick_Clear() { text.text = string.Empty; unityCalendar.Init(); } Github ","permalink":"https://wenrongdev.com/posts/unity-calendar/","summary":"Unity 實做日曆功能。","title":"Unity Calendar"},{"content":"前言 主要是實作 Addressable hotfix 的寫法。\n基本 Unity-Addressable 安裝及 Remote 設定可以參考這篇 Unity 筆記 Addressable Asset System。\n詳細解說可以參考\nUnity Addressables 深入浅出(一)、(二)、(三)\nUnity Addressable 獨立資源包\n實例 Initialization Initial Addressable System 是必要的假如不初始化會造成一些使用上的問題。\n在 Start 上可直接初始化 Addressable System\nIEnumerator Start() { var InitAddressablesAsync = Addressables.InitializeAsync(); yield return InitAddressablesAsync; } Update Catalog Catalog 是所有檔案的紀錄檔(log)，不更新 Catalog 也是能下載 Asset，可是會造成無法 hotfix，所以需要再下載前更一次 Catalog。\nCatalog Path 依 Window 為例，Catalog 更新後會放自動放置在\nC:\\Users\\[PC Name]\\AppData\\LocalLow\\[Company Name]\\[Product Name]\\com.unity.addressables\n名稱 解釋 [PC Name] 系統使用者名稱 [Company Name] Unity 專案 Company Name [Product Name] Unity 專案 Product Name IEnumerator UpdateCatalogCoro() { List\u0026lt;string\u0026gt; catalogsToUpdate = new List\u0026lt;string\u0026gt;(); var checkCatalogHandle = Addressables.CheckForCatalogUpdates(false); yield return checkCatalogHandle; if (checkCatalogHandle.Status == AsyncOperationStatus.Succeeded) catalogsToUpdate = checkCatalogHandle.Result; if (catalogsToUpdate.Count \u0026gt; 0) { var updateCatalogHandle = Addressables.UpdateCatalogs(catalogsToUpdate, false); yield return updateCatalogHandle; } } Update Asset 下載好的 Asset，在測試時不清除是會造成無法測試下載流程，可是可以手動清除下載 Asset。\nAsset Path 依 Window 為例，下載好的 Asset 更新後會放自動放置在\nC:\\Users\\[PC Name]\\AppData\\LocalLow\\Unity\\[Company Name]_[Product Name]\n名稱 解釋 [PC Name] 系統使用者名稱 [Company Name] Unity 專案 Company Name [Product Name] Unity 專案 Product Name Update All Asset 這個方式是使用 AA 系統紀錄 Catalog 取得出來的位置（Locator），在使用 GetDownloadSizeAsync 來確認檔案有無更新，來達成更新所有檔案。\nIEnumerator UpdateAllGroupsCoro() { foreach (var loc in Addressables.ResourceLocators) { foreach (var key in loc.Keys) { var sizeAsync = Addressables.GetDownloadSizeAsync(key); yield return sizeAsync; long totalDownloadSize = sizeAsync.Result; if (sizeAsync.Result \u0026gt; 0) { var downloadAsync = Addressables.DownloadDependenciesAsync(key); while (!downloadAsync.IsDone) { float percent = downloadAsync.PercentComplete; Debug.Log($\u0026#34;{key} = percent {(int)(totalDownloadSize * percent)}/{totalDownloadSize}\u0026#34;); yield return new WaitForEndOfFrame(); } Addressables.Release(downloadAsync); } Addressables.Release(sizeAsync); } } } Update label Asset 這個方式是使用 Label 下載特定資源。\nIEnumerator UpdateLabelAsset(string label) { long updateLabelSize = 0; var async = Addressables.GetDownloadSizeAsync(label); yield return async; if (async.Status == AsyncOperationStatus.Succeeded) updateLabelSize = async.Result; Addressables.Release(async); if (updateLabelSize == 0) { Debug.Log($\u0026#34;{label} last version\u0026#34;); yield break; } yield return DownloadLabelAsset(label); } IEnumerator DownloadLabelAsset(string label) { var downloadAsync = Addressables.DownloadDependenciesAsync(label, false); while (!downloadAsync.IsDone) { float percent = downloadAsync.PercentComplete; Debug.Log($\u0026#34;{label}: {downloadAsync.PercentComplete * 100} %\u0026#34;); yield return new WaitForEndOfFrame(); } Addressables.Release(downloadAsync); Debug.Log($\u0026#34;{label} UpdateAssets finish\u0026#34;); } Clear Asset 刪除 Asset Path 路徑下載的檔案。\nClear All Asset Caching.ClearCache() 是能夠完整的清除下載的所有檔案，但是不能單獨使用，還要搭配 Addressables.ClearDependencyCacheAsync 才能清除 Catalog 紀錄的下載資訊。\nIEnumerator ClearAllAssetCoro() { foreach (var locats in Addressables.ResourceLocators) { var async = Addressables.ClearDependencyCacheAsync(locats.Keys, false); yield return async; Addressables.Release(async); } Caching.ClearCache(); } Clear Label Asset IEnumerator ClearAssetCoro(string label) { var async = Addressables.LoadResourceLocationsAsync(label); yield return async; var locats = async.Result; foreach (var locat in locats) Addressables.ClearDependencyCacheAsync(locat.PrimaryKey); } Github 小結 write something cool\u0026hellip;\n參考連結 ","permalink":"https://wenrongdev.com/posts/unity-addressable/","summary":"主要是實作 Addressable hotfix 的寫法。","title":"Unity Addressable"},{"content":" GitHub ","permalink":"https://wenrongdev.com/posts/unity-particlepath/","summary":"Unity 實作粒子路徑系統。","title":"Unity ParticlePath"},{"content":"前言 Unity 調整 Android、iOS 系統亮度功能。\n使用方式 Dimmer.SetBrightness.DoAction(value); Github 參考連結 Unity から iOS\u0026amp;Android の画面輝度を MAX にする方法\n","permalink":"https://wenrongdev.com/posts/unity-dimmer/","summary":"Unity 調整 Android、iOS 系統亮度功能。","title":"Unity Dimmer"},{"content":"前言 在 UnityEngine.UI.Text 增加 TextSpacing，且調整 TextSpacing 的 Spacing 調整文字間格。\nScripts using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; [AddComponentMenu(\u0026#34;UI/Effects/TextSpacing\u0026#34;)] public class TextSpacing : BaseMeshEffect { #region Struct public enum HorizontalAligmentType { Left, Center, Right } public class Line { // 起點索引 public int StartVertexIndex { get { return _startVertexIndex; } } private int _startVertexIndex = 0; // 終點索引 public int EndVertexIndex { get { return _endVertexIndex; } } private int _endVertexIndex = 0; // 該行佔的點數目 public int VertexCount { get { return _vertexCount; } } private int _vertexCount = 0; public Line(int startVertexIndex, int length) { _startVertexIndex = startVertexIndex; _endVertexIndex = length * 6 - 1 + startVertexIndex; _vertexCount = length * 6; } } #endregion public float Spacing = 1f; public override void ModifyMesh(VertexHelper vh) { if (!IsActive() || vh.currentVertCount == 0) { return; } var text = GetComponent\u0026lt;Text\u0026gt;(); if (text == null) { Debug.LogError(\u0026#34;Missing Text component\u0026#34;); return; } // 水平對齊方式 HorizontalAligmentType alignment; if (text.alignment == TextAnchor.LowerLeft || text.alignment == TextAnchor.MiddleLeft || text.alignment == TextAnchor.UpperLeft) { alignment = HorizontalAligmentType.Left; } else if (text.alignment == TextAnchor.LowerCenter || text.alignment == TextAnchor.MiddleCenter || text.alignment == TextAnchor.UpperCenter) { alignment = HorizontalAligmentType.Center; } else { alignment = HorizontalAligmentType.Right; } var vertexs = new List\u0026lt;UIVertex\u0026gt;(); vh.GetUIVertexStream(vertexs); // var indexCount = vh.currentIndexCount; var lineTexts = text.text.Split(\u0026#39;\\n\u0026#39;); var lines = new Line[lineTexts.Length]; // 根據lines數組中各個元素的長度計算每一行中第一個點的索引，每個字、字母、空母均佔6個點 for (var i = 0; i \u0026lt; lines.Length; i++) { // 除最後一行外，vertexs對於前面幾行都有回車符佔了6個點 if (i == 0) { lines[i] = new Line(0, lineTexts[i].Length + 1); } else if (i \u0026gt; 0 \u0026amp;\u0026amp; i \u0026lt; lines.Length - 1) { lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length + 1); } else { lines[i] = new Line(lines[i - 1].EndVertexIndex + 1, lineTexts[i].Length); } } UIVertex vt; for (var i = 0; i \u0026lt; lines.Length; i++) { for (var j = lines[i].StartVertexIndex; j \u0026lt;= lines[i].EndVertexIndex; j++) { if (j \u0026lt; 0 || j \u0026gt;= vertexs.Count) { continue; } vt = vertexs[j]; var charCount = lines[i].EndVertexIndex - lines[i].StartVertexIndex; if (i == lines.Length - 1) { charCount += 6; } if (alignment == HorizontalAligmentType.Left) { vt.position += new Vector3(Spacing * ((j - lines[i].StartVertexIndex) / 6), 0, 0); } else if (alignment == HorizontalAligmentType.Right) { vt.position += new Vector3(Spacing * (-(charCount - j + lines[i].StartVertexIndex) / 6 + 1), 0, 0); } else if (alignment == HorizontalAligmentType.Center) { var offset = (charCount / 6) % 2 == 0 ? 0.5f : 0f; vt.position += new Vector3(Spacing * ((j - lines[i].StartVertexIndex) / 6 - charCount / 12 + offset), 0, 0); } vertexs[j] = vt; // 以下注意點與索引的對應關係 if (j % 6 \u0026lt;= 2) { vh.SetUIVertex(vt, (j / 6) * 4 + j % 6); } if (j % 6 == 4) { vh.SetUIVertex(vt, (j / 6) * 4 + j % 6 - 1); } } } } } 問題 無法自由換行\n參考連結 UGUI 中 Text 的字间距\nUGUI 中随意调整 Text 中的字体间距\n","permalink":"https://wenrongdev.com/posts/add-text-spacing-for-unity/","summary":"在 UnityEngine.UI.Text 增加 TextSpacing，且調整 TextSpacing 的 Spacing 調整文字間格。","title":"Add Text Spacing for Unity"},{"content":"前言 主要是用來測試虛擬搖桿功能。\n使用 Joystick Pack 支援各輸入端接口偛件。\nTutorial Github ","permalink":"https://wenrongdev.com/posts/mobile-joystick/","summary":"主要是用來測試 Unity 虛擬搖桿功能。","title":"Mobile Joystick"},{"content":"前言 視覺化管理使用路徑，不過目前功能還是很粗糙。\nFeature 視覺化管理\nUsage Create path 之後會在 Assets\\FolderManager\\StreamingAssets\\FolderManager.asset 出現 asset。\nAsset 即是FolderManager.Folders，因此可以直接宣告此 class 使用。\nGithub ","permalink":"https://wenrongdev.com/posts/folder-manager/","summary":"Unity 視覺化管理使用路徑。","title":"Folder Manager"},{"content":"前言 Unity 在 WebGL 時存/讀檔案的方式，檔案是放在 IndexedDB。\nIndexedDB 是有容量大小限制，所以需要注意存儲的檔案大小。\nAbout IndexedDB Working with quota on mobile browsers\nGitHub Introduction File Path\nstring.Format(\u0026quot;{0}/{1}.dat\u0026quot;, Application.persistentDataPath, FileName);\nSave Method\nDataAccess.Save(fileName, bytes);\nLoad Method\nbyte[] bytes = DataAccess.Load(fileName);\nExample Scene\nroot\\Assets\\WebGL\\Example\\Scenes\\Example\n","permalink":"https://wenrongdev.com/posts/data-access-webgl/","summary":"Unity 在 WebGL 時存/讀檔案的方式，檔案是放在 IndexedDB。是有容量大小限制，所以需要注意存儲的檔案大小。","title":"Data Access WebGL"},{"content":"前言 此為使用 Jenkins 輸出 Unity 專案注意事項。\nSetting 須注意 Unity 有無安裝輸出目標平台（Android、iOS、WebGL\u0026hellip;）。\n並且要設定 Jenkins 環境（AndroidSDK、JDK、Unity Editor）。\nJenkins Android SDK 需要新增 Jenkins 環境變數（Environment variable），來設定 Android SDK 路徑。\nJenkins 頁面路徑為 Manage Jenkins -\u0026gt; Configure System -\u0026gt; Global properties。\n設定如下圖：\nName：ANDROID_HOME\nValue：AndroidSDK 路徑。\nJenkins JDK JDK 版本請選 Java SE 8，因為 Unity 只支援 Java SE 8。\nJenkins 頁面路徑為 Manage Jenkins -\u0026gt; Global Tool Configuration -\u0026gt; JDK。\nJenkins Unity3d Plugin 需要至 Plugin Manager 安裝 Unity3d Plugin。\nJenkins 頁面路徑為 Manage Jenkins -\u0026gt; Plugin Manager -\u0026gt; Available\n安裝完成後，需要設定 Unity Editor 路徑。\nName：unity version\nInstallation directory：unity installed path\nJenkins item 基本設置可參考 使用 jenkins 建置 unity3d 專案 介紹。\n最主要是設定 Editor command line arguments。\n頁面路徑：Configure -\u0026gt; General -\u0026gt; Build\n點選 Add build step -\u0026gt; invoke Unity3d Editor，選擇對應的 Unity 編輯器版本。\n在 Editor command line arguments 輸入\n-projectPath \u0026#34;$WORKSPACE/\u0026#34; -executeMethod JenkinsBuild.BuildPlatforms -buildPath \u0026#34;$WORKSPACE\\Builds\u0026#34; -android -batchmode -nographics -quit -buildPath \u0026quot;$WORKSPACE\\Builds\u0026quot; \u0026ldquo;$WORKSPACE\\Builds 輸出放置資料夾路徑。\n-android 為輸出平台，可改為 -windows32、-windows64、-linux64、-macos、-android、-ios、-webgl。\nGitHub Repo reference 使用 jenkins 建置 unity3d 專案\nJenkins for Unity with DigitalOcean\n","permalink":"https://wenrongdev.com/posts/unity-jenkins-build/","summary":"此為使用 Jenkins 輸出 Unity 專案注意事項。","title":"Unity Jenkins Build"},{"content":"前言 測試 LinkImageText 應用。\n主要內容 使用 QuickSheet 當資料庫，讓 FancyScrollView 顯示資料庫名字。\n點擊 FancyScrollView button 會在 HypeLinkText 顯示 name。\n點擊 HypeLinkText 超連結文字，會顯示超連結內容。\nGitHub repo ","permalink":"https://wenrongdev.com/posts/hyperlinks-in-unity-text/","summary":"Unity uGUI Text support insert link and image。","title":"Hyperlinks in Unity Text"},{"content":"前言 前陣子因為專案需要後台推播功能，所以開始測試 FCM(Firebase Cloud Messaging）功能。\n測試的過程一直沒辦法在 APP 不活躍或不喚醒（not active）狀態推送推播訊息。\n後來發現主因是省電模式（Doze mode）導致 APP 無法接受任何推波內容。\n參考連結 https://developer.android.com/training/monitoring-device-state/doze-standby?hl=zh_cn\nhttps://blog.csdn.net/pkorochi/article/details/87186659\n","permalink":"https://wenrongdev.com/posts/fcm-notifications-not-received-on-android/","summary":"沒辦法在 APP 不活躍或不喚醒（not active）狀態推送推播訊息解決方式。","title":"FCM Notifications Not Received on Android"},{"content":"前言 在 Android 9.0 中使用 WebReqesut 時，URL 是需要用 Https 才能正常使用，不然 Response 都是 Error。（Google Doc）\nError Log：Cleartext HTTP traffic to 45.xx.xxx.xx not permitted\nSolution 在 AndroidManifest.xml 的 application 加入 android:usesCleartextTraffic=\u0026quot;true\u0026quot;。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest ...\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;application ... android:usesCleartextTraffic=\u0026#34;true\u0026#34; ...\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 參考連結 Android 中 HTTP 网络请求相关问题\n","permalink":"https://wenrongdev.com/posts/android-p-http-error/","summary":"在 Android 9.0 中使用 WebReqesut 時，URL 是需要用 Https 才能正常使用，不然 Response 都是 Error。","title":"Android P HTTP Error"},{"content":"前言 主要用來 Unity app A 如何傳遞資訊給 Unity app B。\nDemo Script private class PropertyInfo { public string elementA = string.Empty; public string elementB = string.Empty; public string elementC = string.Empty; } public void Launch(string bundleId, string storelink) { bool fail = false; AndroidJavaClass up = new AndroidJavaClass(\u0026#34;com.unity3d.player.UnityPlayer\u0026#34;); AndroidJavaObject ca = up.GetStatic\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;currentActivity\u0026#34;); AndroidJavaObject packageManager = ca.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;getPackageManager\u0026#34;); AndroidJavaObject launchIntent = null; try { launchIntent = packageManager.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;getLaunchIntentForPackage\u0026#34;, bundleId); } catch (Exception e) { fail = true; } if (fail || launchIntent == null) Application.OpenURL(storelink); else { launchIntent.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;putExtra\u0026#34;, \u0026#34;elementA\u0026#34;, LaunchData.elementA); launchIntent.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;putExtra\u0026#34;, \u0026#34;elementB\u0026#34;, LaunchData.elementB); launchIntent.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;putExtra\u0026#34;, \u0026#34;elementC\u0026#34;, LaunchData.elementC); ca.Call(\u0026#34;startActivity\u0026#34;, launchIntent); } up.Dispose(); ca.Dispose(); packageManager.Dispose(); launchIntent.Dispose(); } Property PropertyInfo 是用來接受資訊的 class，這邊可以自行修改。\nGet Android intent Data for Unity\n","permalink":"https://wenrongdev.com/posts/launch-from-within-a-unity-app-another-unity-app-android/","summary":"主要用來 Unity app A 如何傳遞資訊給 Unity app B。","title":"Launch From Within a Unity App Another Unity App Android"},{"content":"前言 主要用來 A App 呼叫 B App 時，B App 該如何接受資料。\n而 B App 是使用 Unity 接收。\nDemo Script private class PropertyInfo { public string elementA = string.Empty; public string elementB = string.Empty; public string elementC = string.Empty; } public class ExternalCall : MonoBehaviour { PropertyInfo info = new PropertyInfo(); private void Awake() { #if (!UNITY_EDITOR \u0026amp;\u0026amp; UNITY_ANDROID) CreatePushClass(new AndroidJavaClass(\u0026#34;com.unity3d.player.UnityPlayer\u0026#34;)); #endif } public void CreatePushClass(AndroidJavaClass UnityPlayer) { #if UNITY_ANDROID AndroidJavaObject currentActivity = UnityPlayer.GetStatic\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;currentActivity\u0026#34;); AndroidJavaObject intent = currentActivity.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;getIntent\u0026#34;); bool elementA_hasExtra = IsBool(intent, \u0026#34;elementA\u0026#34;); bool elementB_hasExtra = IsBool(intent, \u0026#34;elementB\u0026#34;); bool elementC_hasExtra = IsBool(intent, \u0026#34;elementC\u0026#34;); AndroidJavaObject extras = GetExtras(intent); if (extras != null) { if (elementA_hasExtra) info.elementA = GetProperty(extras, \u0026#34;elementA\u0026#34;); if (elementB_hasExtra) info.elementB = GetProperty(extras, \u0026#34;elementB\u0026#34;); if (elementC_hasExtra) info.elementC = GetProperty(extras, \u0026#34;elementC\u0026#34;); } #endif } private bool IsBool(AndroidJavaObject intent, string method) { bool b = false; try { b = intent.Call\u0026lt;bool\u0026gt;(\u0026#34;hasExtra\u0026#34;, method); } catch (Exception e) { Debug.Log(e.Message); } return b; } private AndroidJavaObject GetExtras(AndroidJavaObject intent) { AndroidJavaObject extras = null; try { extras = intent.Call\u0026lt;AndroidJavaObject\u0026gt;(\u0026#34;getExtras\u0026#34;); } catch (Exception e) { Debug.Log(e.Message); } return extras; } private string GetProperty(AndroidJavaObject extras, string name) { string s = string.Empty; try { s = extras.Call\u0026lt;string\u0026gt;(\u0026#34;getString\u0026#34;, name); } catch (Exception e) { Debug.Log(e.Message); } return s; } } Property PropertyInfo 是用來接受資訊的 class，這邊可以自行修改。\nLaunch from within a Unity app another Unity app(Android)\n","permalink":"https://wenrongdev.com/posts/get-android-intent-data-for-unity/","summary":"主要用來 A App 呼叫 B App 時，B App 該如何接受資料。而 B App 是使用 \u003ccode\u003eUnity\u003c/code\u003e 接收。","title":"Get Android Intent Data for Unity"},{"content":"Install 去官網下載 Inno Setup，請下載 Stable Release 版本。\nAdd Language 下載官方提供的 Github，直接下載 Releases 版本，完成後解壓縮。 複製 root/Files/Languages 資料夾，貼上並且覆蓋 Inno Setup 安裝資料夾。 使用方式 可以參考以下腳本，也可以自己寫，不知道寫法可以參考官方文件。\n#define MyAppGUID \u0026#34;{{D0D7EBDD-2493-4086-A306-AB012D2AFA93}\u0026#34; #define MyAppName \u0026#34;Examle\u0026#34; #define MyAppFolder \u0026#34;ExampleFolder\u0026#34; #define MyAppSetupExeName \u0026#34;Examle\u0026#34; #define MyAppExeName \u0026#34;Examle.exe\u0026#34; #define MyAppURL \u0026#34;https://wenrongdev.com/\u0026#34; #define MyAppPublisher \u0026#34;wen rong studio\u0026#34; [Setup] AppId={#MyAppGUID} AppName={#MyAppName} AppVersion=0.1.0 AppVerName={#MyAppName} AppPublisher = {#MyAppPublisher} AppPublisherURL = {#MyAppURL} AppSupportURL = {#MyAppURL} AppUpdatesURL = {#MyAppURL} Compression = lzma2 DefaultDirName={commonpf32}\\{#MyAppFolder} DisableProgramGroupPage=yes DefaultGroupName={#MyAppName} UninstallDisplayIcon={app}ForwardSlash{#MyAppExeName} SolidCompression = no OutputDir = \u0026#34;Setup\u0026#34; OutputBaseFilename = {#MyAppSetupExeName} ShowLanguageDialog=yes // 是否需要分割 DiskSpanning=yes SlicesPerDisk=3 DiskSliceSize=1566000000 /// [Languages] Name: EN; MessagesFile: \u0026#34;compiler:Default.isl\u0026#34; Name: CT; MessagesFile: \u0026#34;compiler:Languages\\Unofficial\\ChineseTraditional.isl\u0026#34; Name: CS; MessagesFile: \u0026#34;compiler:Languages\\Unofficial\\ChineseSimplified.isl\u0026#34; Name: JP; MessagesFile: \u0026#34;compiler:Languages\\Japanese.isl\u0026#34; [CustomMessages] MyAppName = {#MyAppName} MyAppVerName = {#MyAppName} %1 [Messages] BeveledLabel = {#MyAppURL} [Dirs] Name: \u0026#34;{app}\u0026#34;; Permissions: everyone-full [Files] Source: \u0026#34;{#MyAppFolder}\\*\u0026#34;; DestDir: \u0026#34;{app}\\{#MyAppFolder}\u0026#34;; Flags: ignoreversion recursesubdirs [Icons] Name: \u0026#34;{userdesktop}\\{cm:MyAppName}\u0026#34;; Filename: \u0026#34;{app}\\{#MyAppFolder}\\{#MyAppExeName}\u0026#34;; [Code] function GetNumber(var temp: String): Integer; var part: String; pos1: Integer; begin if Length(temp) = 0 then begin Result := -1; Exit; end; pos1 := Pos(\u0026#39;.\u0026#39;, temp); if (pos1 = 0) then begin Result := StrToInt(temp); temp := \u0026#39;\u0026#39;; end else begin part := Copy(temp, 1, pos1 - 1); temp := Copy(temp, pos1 + 1, Length(temp)); Result := StrToInt(part); end; end; function CompareInner(var temp1, temp2: String): Integer; var num1, num2: Integer; begin num1 := GetNumber(temp1); num2 := GetNumber(temp2); if (num1 = -1) or (num2 = -1) then begin Result := 0; Exit; end; if (num1 \u0026gt; num2) then begin Result := 1; end else if (num1 \u0026lt; num2) then begin Result := -1; end else begin Result := CompareInner(temp1, temp2); end; end; function CompareVersion(str1, str2: String): Integer; var temp1, temp2: String; begin temp1 := str1; temp2 := str2; Result := CompareInner(temp1, temp2); end; function InitializeSetup(): Boolean; var oldVersion: String; uninstaller: String; ErrorCode: Integer; vCurID :String; vCurAppName :String; begin vCurID:= \u0026#39;{#SetupSetting(\u0026#34;AppId\u0026#34;)}\u0026#39;; vCurAppName:= \u0026#39;{#SetupSetting(\u0026#34;AppName\u0026#34;)}\u0026#39;; vCurID:= Copy(vCurID, 2, Length(vCurID) - 1); if RegKeyExists(HKEY_LOCAL_MACHINE, \u0026#39;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#39; + vCurID + \u0026#39;_is1\u0026#39;) then begin RegQueryStringValue(HKEY_LOCAL_MACHINE, \u0026#39;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#39; + vCurID + \u0026#39;_is1\u0026#39;, \u0026#39;DisplayVersion\u0026#39;, oldVersion); if (CompareVersion(oldVersion, \u0026#39;{#SetupSetting(\u0026#34;AppVersion\u0026#34;)}\u0026#39;) \u0026lt; 0) then begin if MsgBox(\u0026#39;Version \u0026#39; + oldVersion + \u0026#39; of \u0026#39; + vCurAppName + \u0026#39; is already installed. Continue to use this old version?\u0026#39;, mbConfirmation, MB_YESNO) = IDYES then begin Result := False; end else begin RegQueryStringValue(HKEY_LOCAL_MACHINE, \u0026#39;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\\u0026#39; + vCurID + \u0026#39;_is1\u0026#39;, \u0026#39;UninstallString\u0026#39;, uninstaller); ShellExec(\u0026#39;runas\u0026#39;, uninstaller, \u0026#39;/SILENT\u0026#39;, \u0026#39;\u0026#39;, SW_HIDE, ewWaitUntilTerminated, ErrorCode); Result := True; end; end else begin MsgBox(\u0026#39;Version \u0026#39; + oldVersion + \u0026#39; of \u0026#39; + vCurAppName + \u0026#39; is already installed. This installer will exit.\u0026#39;, mbInformation, MB_OK); Result := False; end; end else begin Result := True; end; end; 修改方式 假如是使用複製舊有的 .iss 檔，只需要修改幾個需要注意的文字即可。\n正常的資料夾結構\nFolder Description ExampleFolder 打包前的資料夾 Setup Inno Setup 輸出的資料夾 .iss Inno Setup Script 修改 .iss #define MyAppGUID \u0026#34;GUID\u0026#34; #define MyAppName \u0026#34;Examle\u0026#34; #define MyAppFolder \u0026#34;ExampleFolder\u0026#34; #define MyAppSetupExeName \u0026#34;Examle\u0026#34; #define MyAppExeName \u0026#34;Examle.exe\u0026#34; #define MyAppURL \u0026#34;https://wenrongdev.com/\u0026#34; #define MyAppPublisher \u0026#34;wen rong studio\u0026#34; 需修改地方 Arg Description MyAppGUID 安裝系統 GUID，產生方式為 Tools/Generated GUID。 MyAppName 桌面路徑名稱 。 MyAppFolder 安裝目錄名稱。 MyAppSetupExeName Inno Setup 輸出安裝檔名稱 。 取得 GUID 方法 Github ","permalink":"https://wenrongdev.com/posts/example-inno-setup/","summary":"簡易使用 Inno Setup 打包教學。","title":"Example Inno Setup"},{"content":"前言 因為某些程式開啟時，會跳出需要系統管理員（Administrator）權限執行程式，也導致了只要是ㄧ般使用者每次開啟時都需要輸入系統管理員密碼來執行。為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。\n已知限制條件 程式必須以 Administrator 執行 一般使用者可以執行 不可完全關閉 Windows UAC 解決方式 根據不變更 UAC 安全性，但執行程式時又不擾民的設定方式，可以在 Windows Regedit 新增白名單。\nWin+R 輸入 regedit 執行 根據此路徑尋找 HKEY_CURRENT_USERS\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers 右鍵新增字串值，名稱為程式（exe）路徑、資料為~ RunAsInvoker C# 解決方式 public class RegEditWhiteList { public string keyName { get; set; } private readonly string root = @\u0026#34;Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers\u0026#34;; private readonly string keyValue = \u0026#34;~ RunAsInvoker\u0026#34;; public RegEditWhiteList(string keyName) { this.keyName = keyName; } public void SendRegedit() { RegistryKey key = Registry.CurrentUser.OpenSubKey(root, true); key.SetValue(keyName, keyValue,RegistryValueKind.String); key.Close(); } } GitHub 使用方式 因為修改註冊碼是修正當前使用者的註冊碼，因此只要換使用者就需要再新增一次白名單。\n參考資料 不變更 UAC 安全性，但執行程式時又不擾民的設定方式\n","permalink":"https://wenrongdev.com/posts/whitelist-for-windows-uac/","summary":"為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。","title":"Whitelist for Windows UAC"},{"content":"前言 Unity 2019.2.11f1 Vuforia 8.5.9 iOS Build and Run Error ld: library not found for -liPhone-lib clang: error: linker command failed with exit code 1 (use -v to see invocation) Solution - iOS Build and Run Error Build Setting -\u0026gt; Search Paths -\u0026gt; Library Search Paths\n移除 \u0026quot;$(SECROOT)\u0026quot; 參數\niOS Archive Error ld: warning: ignoring file ... building for iOS-armv7 but attempting to link with file built for iOS-arm64. Solution - iOS Archive Error 根據 Vuforia Engine Release Notes 在 v8.1.7之後不支援 32-bit，並且最低支援 iOS 11，因此需要把專案版本最低版本設定為 iOS。\n設定 iOS architectures\nBuild Setting -\u0026gt; Architectures -\u0026gt; Architectures\nArchitectures 改為 Standard architectures\n設定 iOS 版本\nBuild Setting -\u0026gt; Deployment -\u0026gt; iOS Deployment Target\niOS Deployment Target 改為 iOS 11.0\niOS Distribution Error ERROR ITMS-90534 Solution - iOS Distribution Error 請使用 Xcode 11.2.1 輸出，即可修正。\n參考文章 Unity Xcode Error \u0026ldquo;library not found for -\u0026rdquo; の解決方法\nCan\u0026rsquo;t submit apps to AppStore: ERROR ITMS-90534: \u0026ldquo;Invalid Toolchain\n","permalink":"https://wenrongdev.com/posts/ios-build-note-for-unity-2019-vuforia/","summary":"Vuforia iOS Build and Run Error。","title":"IOS Build Note for Unity 2019 Vuforia"},{"content":"前言 由於 iTunes 12.6 之後不提供 .ipa 檔安裝，導致無法提供測試 App，所以有人研究出很多安裝方式。不過這邊主要是介紹 OTA 的方式。\n其他的安裝方式：iTunes 12.7 移除了 Apps 的選項，我該如何安裝 .ipa 檔案到 iOS 裝置？\nUsing OTA 使用 OTA（Over-the-Air）需要有三個檔案 .ipa(ad-Hoc)、.plist、index.html\n.ipa(ad-Hoc) 需要上傳去雲端空間，目前選擇的雲端空間是 Dropbox。\n還需要 Host Website 上傳 .plist、index.html，目前選擇的是 GitHub。\n所以只要使用 Host Website 就可以安裝了。\n參考文章：Error when distributing an IPA over the air with dropbox - iOS 7.1\nUpload .ipa to Dropbox and Get public link 先把輸出好的 .ipa(ad-Hoc) 上傳至 Dropbox 並且設定分享。\n將分享網址裡的 www.dropbox.com 替換為 dl.dropboxusercontent.com。\n紀錄修改 public link。\nCreate manifest.plist \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;items\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;assets\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;software-package\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;url\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;http://YOUR_SERVER_URL/YOUR-IPA-FILE.ipa\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;metadata\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;bundle-identifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.yourCompany.productName\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;bundle-version\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;1.0.0\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;software\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;title\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;YOUR APP NAME\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 修改好 public link、app info 就完成 .plist。\nCreate index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;App install\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;builds\u0026lt;/h2\u0026gt; \u0026lt;a href=\u0026#34;itms-services://?action=download-manifest\u0026amp;url=http://YOUR_SERVER_URL/manifest.plist\u0026#34;\u0026gt; App\u0026lt;/a\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 把 url=http://YOUR_SERVER_URL/manifest.plist 替換成 Website manifest.plist。\nHosting using Github Create a new repository（教學文章） 上傳 manifest.plist、index.html 得到 Github Website index.html就可以安裝 .ipa\n參考文章 iTunes 12.7 移除了 Apps 的選項，我該如何安裝 .ipa 檔案到 iOS 裝置？\n從網路上下載 ipa 檔並且安裝在 iPhone or iPad(Download and install an ipa from url on iOS)\nError when distributing an IPA over the air with dropbox - iOS 7.1\n使用 GitHub 免費製作個人網站\n","permalink":"https://wenrongdev.com/posts/install-ipa-with-ota/","summary":"由於 iTunes 12.6 之後不提供 .ipa 檔安裝，導致無法提供測試 App，所以有人研究出很多安裝方式。不過這邊主要是介紹 OTA 的方式。","title":"Install IPA With OTA"},{"content":"前言 在 Unity API 中有 Application.systemLanguage 可以取得系統語言。可是 Unity 5.3 用於 iOS 上，只要是裝置為中文語系一律回傳 SystemLanguage.Chinese，無法判別簡 / 繁語系，因此才研究怎麼取得 Windows、Android、iOS 原生語系。\nWindows Platform 利用 GetSystemDefaultLCID 取得本機端語系，再利用 CultureInfo.GetCultureInfo 轉化為本機端語系文化。\n[DllImport(\u0026#34;kernel32.dll\u0026#34;)] 參考文章\nAndroid Platform 直接呼叫原生系統 API 取得。\nprivate static string CurrentAndroidLanguage() { string result = \u0026#34;\u0026#34;; using (AndroidJavaClass cls = new AndroidJavaClass(\u0026#34;java.util.Locale\u0026#34;)) { if (cls != null) { using (AndroidJavaObject locale = cls.CallStatic(\u0026#34;getDefault\u0026#34;)) { if (locale != null) { result = locale.Call(\u0026#34;getLanguage\u0026#34;) + \u0026#34;_\u0026#34; + locale.Call(\u0026#34;getDefault\u0026#34;); Debug.Log(\u0026#34;Android lang: \u0026#34; + result); } else { Debug.Log(\u0026#34;locale null\u0026#34;); } } } else { Debug.Log(\u0026#34;cls null\u0026#34;); } } return result; } 參考文章\niOS Platfrom 製作一個 .mm 文件，內容如下\nchar* cStringCopy(const char* string) { if(string == NULL){ return NULL; } char* newString = (char*)malloc(strlen(string) + 1); strcpy(newString, string); return newString; } extern \u0026#34;C\u0026#34; { const char* CurIOSLang () { NSArray *languages = [NSLocale preferredLanguages]; NSString *CurrentLanguage = [languages objectAtIndex:0]; return cStringCopy([CurrentLanguage UTF8String]); } } 在 C# 寫出 CurIOSLang 的接口\n[DllImport(\u0026#34;__Internal\u0026#34;)] private static extern string CurIOSLang(); 這樣就可以在 Unity 直接呼叫 CurIOSLan 取得 iOS 語系了。\n參考文章\nGithub repo ","permalink":"https://wenrongdev.com/posts/unity-5.3-native-system-language/","summary":"使用 Unity 取得 Windows、Android、iOS 原生語系。","title":"Unity 5.3 Native System Language"},{"content":"前言 執行 WebGL 時都會有 Unity Logo \u0026amp; Loading。目前此專案修改 Unity Logo 的部分。\n需要更詳細的內容可以參考官方文件（Unity Document）。\n會比較建議使用 Responsive WebGL Template，省去自己測試修改的麻煩，不過還是需要改 Logo、Icon 的部分。\nSetting Up Your Template Import Unitypackage\nSet up Unity Player Setting Edit -\u0026gt; Project Settings -\u0026gt; Player, On the WebGL tab -\u0026gt; Resolution and Presentation -\u0026gt; Selcet LogoTemplates\nChange Your Logo\nLogo 規格建議不要太大張。\nPath: root/Assets/WebGLTemplates/LogoTemplate/logo.png\nGitHub repo 參考文章\n","permalink":"https://wenrongdev.com/posts/unity-webgl-template/","summary":"執行 WebGL 時都會有 Unity Logo \u0026amp; Loading。目前此專案修改 Unity Logo 的部分。","title":"Unity WebGL Template"},{"content":"前言 此 Script 用於 WebGL RectMask2D 失去作用的簡易修正。\n建議還是先輸出測試確定 RectMask2D 失效再使用此 Script。\n使用方式 直接在 Canvas 物件底下 Add Component FixRectMask2dWebGL 即可。\nScript public class FixRectMask2dWebGL : MonoBehaviour { #if PlatformWebGL private void Awake() { var items = GetComponentsInChildren\u0026lt;MaskableGraphic\u0026gt;(true); for (int i = 0; i \u0026lt; items.Length; i++) { Material m = items[i].materialForRendering; if (m != null) m.EnableKeyword(\u0026#34;UNITY_UI_CLIP_RECT\u0026#34;); } } #endif } 參考文章\n","permalink":"https://wenrongdev.com/posts/unity-webgl-rectmask2d-does-not-work/","summary":"用於 WebGL RectMask2D 失去作用的簡易修正。","title":"Unity WebGL RectMask2D Does Not Work"}]