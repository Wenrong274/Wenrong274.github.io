<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CSharp on Wenrong&#39;s Note</title>
    <link>https://wenrongdev.com/tags/csharp/</link>
    <description>Recent content in CSharp on Wenrong&#39;s Note</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 22 Jun 2024 19:02:04 +0800</lastBuildDate>
    <atom:link href="https://wenrongdev.com/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C# 淺複製與深複製</title>
      <link>https://wenrongdev.com/posts/csharpshallowcopyanddeepcopy/</link>
      <pubDate>Sat, 22 Jun 2024 19:02:04 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/csharpshallowcopyanddeepcopy/</guid>
      <description>C# 淺複製與深複製</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>之前有講到 <a href="../csharpvaluetypereferencetype">C# Value Type、Reference Type 的差異</a>，現在來講一下淺複製（Shallow Copy）與深複製（Deep Copy）。</p>
<h2 id="淺複製">淺複製</h2>
<p>將原有物件的欄位依照其型別來複製，Value Type 欄位複製其數值到另一個空間，Reference Type 欄位則是複製其參考到另一個空間，因此此兩物件的 Refetence Type 都是參考到同一 instance。</p>
<h3 id="淺複製方式">淺複製方式</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Address</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Street = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> City = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Age = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Address Address = <span style="color:#66d9ef">new</span> Address();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Person ShallowCopy()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (Person)<span style="color:#66d9ef">this</span>.MemberwiseClone();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>Person origin = <span style="color:#66d9ef">new</span> Person()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Name = <span style="color:#e6db74">&#34;Sam&#34;</span>,
</span></span><span style="display:flex;"><span>    Age = <span style="color:#ae81ff">20</span>,
</span></span><span style="display:flex;"><span>    Address = <span style="color:#66d9ef">new</span> Address()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Street = <span style="color:#e6db74">&#34;123 Main St&#34;</span>,
</span></span><span style="display:flex;"><span>        City = <span style="color:#e6db74">&#34;Anytown&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Person copy = origin.ShallowCopy();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>copy.Name = <span style="color:#e6db74">&#34;John&#34;</span>;
</span></span><span style="display:flex;"><span>copy.Age = <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>copy.Address.Street = <span style="color:#e6db74">&#34;456 Main St&#34;</span>;
</span></span><span style="display:flex;"><span>copy.Address.City = <span style="color:#e6db74">&#34;Taiwan&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">&#34;Shallow Copy&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Origin: Sam, 20, 456 Main St, Taiwan</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">$&#34;Origin: {origin.Name}, {origin.Age}, {origin.Address.Street}, {origin.Address.City}&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Copy: John, 30, 456 Main St, Taiwan</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">$&#34;Copy: {copy.Name}, {copy.Age}, {copy.Address.Street}, {copy.Address.City}&#34;</span>);
</span></span></code></pre></div><p>輸出結果</p>
<p><code>Origin: Sam, 20, 456 Main St, Taiwan</code></p>
<p><code>Copy: John, 30, 456 Main St, Taiwan</code></p>
<p><code>Name</code> 是 String，可是沒有跟著改變，可以先看<a href="../csharpreferencetypestring">C# Reference Type String</a>這篇。</p>
<p><code>Age</code> 是 int，也是 Value Type，所以會改變。</p>
<p><code>Address</code> 是 class 是 Reference Type，因為淺複製的關係導致他們（Origin、Copy）有一起改變</p>
<h2 id="深複製">深複製</h2>
<p>ValueType 與<code>淺複製</code>相同，主要差異是<code>深複製</code>的 Reference Type 欄位會產生新的 instance，所以其倆欄位是參考到不同 instance 的。</p>
<h3 id="深複製方式">深複製方式</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Address</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Street = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> City = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name = <span style="color:#66d9ef">string</span>.Empty;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Age = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Address Address = <span style="color:#66d9ef">new</span> Address();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Person DeepCopy()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Person clone = (Person)<span style="color:#66d9ef">this</span>.MemberwiseClone();
</span></span><span style="display:flex;"><span>        clone.Address = <span style="color:#66d9ef">new</span> Address
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Street = <span style="color:#66d9ef">this</span>.Address.Street,
</span></span><span style="display:flex;"><span>            City = <span style="color:#66d9ef">this</span>.Address.City
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> clone;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>Person origin = <span style="color:#66d9ef">new</span> Person()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Name = <span style="color:#e6db74">&#34;Sam&#34;</span>,
</span></span><span style="display:flex;"><span>    Age = <span style="color:#ae81ff">20</span>,
</span></span><span style="display:flex;"><span>    Address = <span style="color:#66d9ef">new</span> Address()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Street = <span style="color:#e6db74">&#34;123 Main St&#34;</span>,
</span></span><span style="display:flex;"><span>        City = <span style="color:#e6db74">&#34;Anytown&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Person copy = origin.DeepCopy();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>copy.Name = <span style="color:#e6db74">&#34;John&#34;</span>;
</span></span><span style="display:flex;"><span>copy.Age = <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>copy.Address.Street = <span style="color:#e6db74">&#34;456 Main St&#34;</span>;
</span></span><span style="display:flex;"><span>copy.Address.City = <span style="color:#e6db74">&#34;Taiwan&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">&#34;Shallow Copy&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Origin: Sam, 20, 123 Main St, Anytown</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">$&#34;Origin: {origin.Name}, {origin.Age}, {origin.Address.Street}, {origin.Address.City}&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Copy: John, 30, 456 Main St, Taiwan</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#e6db74">$&#34;Copy: {copy.Name}, {copy.Age}, {copy.Address.Street}, {copy.Address.City}&#34;</span>);
</span></span></code></pre></div><p><code>Origin: Sam, 20, 123 Main St, Anytown</code></p>
<p><code>Copy: John, 30, 456 Main St, Taiwan</code></p>
<p>與淺複製的差異，深複製的 <code>Address</code> 欄位也會產生新的 instance，在修改 <code>copy.Address</code> 時，不會影響到 <code>origin.Address</code>。</p>
<h2 id="參考連結">參考連結</h2>
<p><a href="https://dotblogs.com.tw/lazycodestyle/2016/06/18/183737">C# 複製物件的方式比較</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>C# Reference Type String</title>
      <link>https://wenrongdev.com/posts/csharpreferencetypestring/</link>
      <pubDate>Sat, 22 Jun 2024 17:40:52 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/csharpreferencetypestring/</guid>
      <description>淺談 C# Reference Type String</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>之前有提到 <a href=".../csharpvaluetypereferencetype">C# Value Type、Reference Type 的差異</a>，提到 String 是 Reference Type，可是在使用時卻很像 Value Type。</p>
<h3 id="比較值">比較值</h3>
<p>Value Type 以 <code>int</code> 為舉例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b = a;
</span></span><span style="display:flex;"><span>a = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>Console.WriteLine(a == b); <span style="color:#75715e">// 輸出: false</span>
</span></span></code></pre></div><p><code>b</code> 並沒有隨著 <code>a</code> 改變，看得出 int 是 Value Type。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str1 = <span style="color:#e6db74">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str2 = str1;
</span></span><span style="display:flex;"><span>str1 = <span style="color:#e6db74">&#34;def&#34;</span>;
</span></span><span style="display:flex;"><span>Console.WriteLine(str1 == str2); <span style="color:#75715e">// 輸出:  false</span>
</span></span></code></pre></div><p>修改 str1 卻沒有影響到 str2，所以會覺得 string 也是 Value Type(?)。</p>
<h3 id="比較地址">比較地址</h3>
<p>使用 <code>object.ReferenceEquals</code> 來比較，假如是 Value Type，則會輸出 <code>false</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#66d9ef">object</span>.ReferenceEquals(a, b)); <span style="color:#75715e">// 輸出: false</span>
</span></span></code></pre></div><p><code>int</code> 確實是 Value Type，所以會輸出 false。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str1 = <span style="color:#e6db74">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str2 =  <span style="color:#e6db74">&#34;abc&#34;</span>;
</span></span><span style="display:flex;"><span>Console.WriteLine(<span style="color:#66d9ef">object</span>.ReferenceEquals(str1, str2)); <span style="color:#75715e">// 輸出: true</span>
</span></span></code></pre></div><p>比較結果為 true，假如 String 是 Value Type，應該會與 int 的結果一樣會是 false。</p>
<p>也就是 String 其實是 Reference Type。</p>
<h2 id="string-為什麼是-reference-type">String 為什麼是 Reference Type</h2>
<p><a href="https://blog.csdn.net/daigualu/article/details/59096659">.NET 框架-string 是 value or reference type?</a></p>
<p>這裡面提到兩點</p>
<ul>
<li>
<p>String 對象，若值相同，則其引用地址相同。</p>
</li>
<li>
<p>String 對象，若值不等，則其引用地址不等。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str1 = <span style="color:#e6db74">&#34;abc&#34;</span>; <span style="color:#75715e">//str1指向記憶體位置 addressA 為 abc</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str2 = str1; <span style="color:#75715e">//str2指向記憶體位置 addressA</span>
</span></span><span style="display:flex;"><span>str1 = <span style="color:#e6db74">&#34;def&#34;</span>; <span style="color:#75715e">//str1新指向記憶體位置 addressB 為 def</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(str1 == str2); <span style="color:#75715e">// 輸出:  false</span>
</span></span></code></pre></div><h2 id="string-特點">String 特點</h2>
<p>String 特點就是具有不可變性（immutable），一旦 new String 在記憶體(managed heap)上為它分配一塊連續記憶體空間，我們將不能以任何方式對這個 String 進行修改。所有對這個 String 進行各項操作而返回的 String，實際上是另一個重新 new 的 String，其本身並不會產生任何變化。</p>
<h3 id="string-效能如何">String 效能如何？</h3>
<p>從上面就可以知道 String 有不可變性，一旦創建了就不能修改值，每次修改 String 都會產生一個新的 String，所以 String 效能比較低。</p>
<p>所以需要經常性操作 String 可以考慮使用 <a href="https://learn.microsoft.com/zh-tw/dotnet/api/system.text.stringbuilder?view=net-8.0">StringBuilder</a>。</p>
<h2 id="結論">結論</h2>
<p>來自 ChatGPT 的解釋</p>
<p>C# String 有以下特性：</p>
<ul>
<li>
<p>String 有不可變性：一旦創建 string，它的內容就不能被改變。</p>
</li>
<li>
<p>賦值操作的實際行為：當執行 <code>str = &quot;abc&quot;</code> 時，實際上是創建了一個新的 string 對象，而不是修改原有的對象。然後，變量 <code>str</code> 被重新指向這個新對象。</p>
</li>
<li>
<p>為什麼 str2 不變：當執行 <code>string str2 = str1</code> 時，str1 和 str2 確實指向了同一個對象。但是當 str1 被賦予新值時，它指向了一個新對象，而 str2 仍然指向原來的對象。</p>
</li>
<li>
<p>值類型的行為：這種行為看起來很像值類型，但 string 仍然是引用類型。這是因為 string 的不可變性和特殊的內存管理方式。</p>
</li>
<li>
<p>性能和內存管理：這種設計有助於提高性能和簡化內存管理，特別是在字符串被廣泛使用的情況下。</p>
</li>
<li>
<p>字符串池（String Interning）：C#使用字符串池來優化內存使用。相同的字符串字面量會指向內存中的同一位置。</p>
</li>
</ul>
<p>這種行為是 C# 語言設計的一個特點，旨在結合引用類型的靈活性和值類型的一些優勢。它可能看起來有點反直覺，但在實際使用中通常是有益的。</p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>C# Class 和 Struct 選擇</title>
      <link>https://wenrongdev.com/posts/csharpclassandstruct/</link>
      <pubDate>Wed, 12 Jun 2024 22:47:08 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/csharpclassandstruct/</guid>
      <description>C# Class 和 Struct 選擇</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>之前有講到 <a href="../csharpvaluetypereferencetype">C# Value Type、Reference Type 的差異</a>，現在來講一下 Class 和 Struct 選擇。</p>
<p>從上一篇的文章中可以知道 Class 是 Reference type，而 Struct 是 Value type。</p>
<h2 id="如何選擇">如何選擇</h2>
<p>根據<a href="https://learn.microsoft.com/zh-tw/dotnet/standard/design-guidelines/choosing-between-class-and-struct">在類別和結構之間選擇</a></p>
<blockquote>
<p>作為經驗規則，架構中大部分的類型應該為類別。 不過，在某些情況下，實值型別的特性會使它更適合使用結構。</p>
</blockquote>
<p>可以知道其實大部分時都是使用 Class，但在某些情況下使用 Struct 會比較適合。</p>
<h3 id="什麼時候使用-struct">什麼時候使用 Struct</h3>
<p><strong>如果類型的執行個體很小，且通常短期或通常內嵌在其他物件中，請考慮定義結構，而不是類別。</strong></p>
<p>除非類型具有下列所有特性，否則請「避免」定義結構：</p>
<ul>
<li>
<p>其以邏輯方式表示單一值，類似於基本類型 (int、double 等)。</p>
</li>
<li>
<p>其執行個體大小低於 16 個位元組。</p>
</li>
<li>
<p>類型為不可變，</p>
</li>
<li>
<p>而且不需要經常進行 Box。</p>
</li>
</ul>
<p><strong>在所有其他情況下，您應該將類型定義為類別。</strong></p>
<h2 id="參考連結">參考連結</h2>
<p><a href="https://hackmd.io/@SuFrank/H1coLlCaq">一起學 Class and Struct (C#)</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>C# Value Type、Reference Type 的差異</title>
      <link>https://wenrongdev.com/posts/csharpvaluetypereferencetype/</link>
      <pubDate>Tue, 11 Jun 2024 22:38:53 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/csharpvaluetypereferencetype/</guid>
      <description>討論 C# Value Type、Reference Type 的差異</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>在公司讀書會與同事討論淺複製與深複製的差異和使用時機時，聊到 Reference Type、Value Type 的不同，但是要講淺複製與深複製之前要先講 Reference Type、Value Type 的差異。</p>
<h2 id="value-type-有哪些">Value Type 有哪些</h2>
<ol>
<li>
<p>整數的數字型別：sbyte、byte、short、ushort、int、uint、long、ulong、nint、nuint</p>
</li>
<li>
<p>浮點數值型別：float、double、decimal</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/numeric-conversions">內建數值轉換</a></p>
</li>
<li>
<p>bool</p>
</li>
<li>
<p>char</p>
</li>
<li>
<p>enum</p>
</li>
<li>
<p>struct</p>
</li>
<li>
<p>ref struct</p>
</li>
<li>
<p>tuples</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可為 Null 的值類型 (C# 參考)</a></p>
</li>
</ol>
<p>參考：<a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/value-types">實值類型 (C# 參考)</a></p>
<h2 id="reference-type-有哪些">Reference Type 有哪些</h2>
<ol>
<li>
<p>宣告參考型別：class、interface、delegate、record</p>
</li>
<li>
<p>內建參考類型：dynamic、object、string</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">可為 Null 的參考型別</a></p>
</li>
<li>
<p>集合和陣列：集合（List、Dictionary）、陣列（int[]、string[]）</p>
</li>
</ol>
<p>參考：<a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/reference-types">參考型別 (C# 參考)</a></p>
<h2 id="value-typereference-type-的差異">Value Type、Reference Type 的差異</h2>
<p>根據<a href="https://learn.microsoft.com/zh-tw/dotnet/standard/design-guidelines/choosing-between-class-and-struct">在類別和結構之間選擇</a>裡的一段話，可以分出 5 點差異。</p>
<h3 id="1-存放記憶體">1. 存放記憶體</h3>
<blockquote>
<p>參考型別會配置在回收的堆積和記憶體上，而實值型別則會配置在堆疊上，或內嵌在包含型別上，並在堆疊回溯時或其包含類型解除配置時解除配置。</p>
<p>因此，實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。</p>
</blockquote>
<p>可以得知主要是在存放的記憶體差異，因此 Value Type 配置和解除配置的成本比 Reference Type 成本更低。</p>
<p>實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。</p>
<h3 id="2-陣列">2. 陣列</h3>
<blockquote>
<p>參考型別的陣列會以換行方式配置，這表示陣列元素只是位於堆積上之參考型別執行個體的參考。實值型別陣列會內嵌配置，這表示陣列元素是實值型別實際的執行個體。</p>
<p>因此，實值型別陣列的配置和解除配置的成本會遠比參考型別陣列的配置和解除配置的成本來得低。此外，在大部分情況下，實值型別陣列會呈現較佳的參考位置。</p>
</blockquote>
<p>Value Type 陣列的配置和解除配置成本較低，且通常在記憶體存取表現上優於 Reference Type 陣列。然而，Reference Type 陣列在處理複雜的物件或需要物件參考的情境中仍有其必要性。</p>
<h3 id="3-記憶體使用量">3. 記憶體使用量</h3>
<blockquote>
<p>強制轉型為參考型別或其實作的其中一個介面時，實值型別會進行 Boxed。 當強制轉型回實值型別時，它們會進行 Unboxed。</p>
<p>因為 Box 是配置在堆積上且被回收記憶體的物件，所以過多 Boxing 和 unboxing 可能會對堆積、記憶體回收行程，以及最終是應用程式的效能造成負面影響。</p>
</blockquote>
<p>強制轉型為 Reference Type 時，Value Type 會進行 Boxed。 當強制轉型回實值型別時會進行 Unboxed，過多的 Boxed 和 Unboxed 會增加垃圾回收（GC）的負擔，從而影響應用程式效能。</p>
<h3 id="4-複製參考">4. 複製參考</h3>
<blockquote>
<p>參考型別指派會複製參考，而實值型別指派則會複製整個值。 因此，大型參考型別的指派成本比大型實值型別的指派成本更低。</p>
</blockquote>
<h3 id="5-傳遞方式">5. 傳遞方式</h3>
<blockquote>
<p>參考型別會以傳址方式傳遞，而實值型別則是以傳值方式傳遞。對參考型別的執行個體所做的變更會影響所有指向執行個體的參考。實值型別執行個體會在以傳值方式傳遞時複製。變更實值型別的執行個體時，它必然不會影響其任何複本。</p>
<p>由於不會由使用者明確建立複本，而是會在傳回引數或傳回值時隱含建立，因此可以變更的實值型別可能會對許多使用者造成混淆。 因此，實值型別應該為不可變。</p>
</blockquote>
<p>由於 Value Type 在傳遞過程中會複製，變更複本時不會影響原始值，這有時會讓使用者感到困惑，因為預期的變更並未反映在原始變數上。</p>
<p>為了避免這種混淆，Value Type 通常應設計為不可變（immutable）。不可變的 Value Type 一旦創建，其狀態就無法改變，這樣可以確保每個複本都是一致且獨立的。</p>
<ul>
<li>Reference Type</li>
</ul>
<p>傳遞物件的記憶體地址。因此，對該物件所做的變更會影響所有持有該物件地址的參考。</p>
<p>當 Reference Type 的物件進行變更時，因為所有指向該物件的參考都是同一個實例，所有持有該參考的變數都會受到變更影響。</p>
<ul>
<li>Value Type</li>
</ul>
<p>會複製該值並將複本傳遞給目標位置。因此，對複本的變更不會影響原始值。</p>
<p>當傳遞 Value Type 並對其進行變更時，因為是對複本進行操作，原始實例不會受到任何影響。這意味著每個複本都是獨立的。</p>
<h2 id="參考連結">參考連結</h2>
<p><a href="https://hackmd.io/@SuFrank/H1coLlCaq">一起學 Class and Struct</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Whitelist for Windows UAC</title>
      <link>https://wenrongdev.com/posts/whitelist-for-windows-uac/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://wenrongdev.com/posts/whitelist-for-windows-uac/</guid>
      <description>為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>因為某些程式開啟時，會跳出需要系統管理員（Administrator）權限執行程式，也導致了只要是ㄧ般使用者每次開啟時都需要輸入系統管理員密碼來執行。為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。</p>
<h2 id="已知限制條件">已知限制條件</h2>
<ol>
<li>程式必須以 Administrator 執行</li>
<li>一般使用者可以執行</li>
<li>不可完全關閉 Windows UAC</li>
</ol>
<h2 id="解決方式">解決方式</h2>
<p>根據<a href="https://www.taode.idv.tw/wordpress/?p=639">不變更 UAC 安全性，但執行程式時又不擾民的設定方式</a>，可以在 Windows Regedit 新增白名單。</p>
<ol>
<li>Win+R 輸入 regedit 執行</li>
<li>根據此路徑尋找 <code>HKEY_CURRENT_USERS\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers</code></li>
<li>右鍵新增字串值，名稱為程式（exe）路徑、資料為<code>~ RunAsInvoker</code></li>
</ol>
<h2 id="c-解決方式">C# 解決方式</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CSharp" data-lang="CSharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RegEditWhiteList</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> keyName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> root = <span style="color:#e6db74">@&#34;Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> keyValue = <span style="color:#e6db74">&#34;~ RunAsInvoker&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> RegEditWhiteList(<span style="color:#66d9ef">string</span> keyName)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.keyName = keyName;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SendRegedit()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        RegistryKey key = Registry.CurrentUser.OpenSubKey(root, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        key.SetValue(keyName, keyValue,RegistryValueKind.String);
</span></span><span style="display:flex;"><span>        key.Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="githubrepo"><a href="https://github.com/Wenrong274/UACWhitelist">GitHub</a></h2>
<h3 id="使用方式">使用方式</h3>
<p>因為修改註冊碼是修正當前使用者的註冊碼，因此只要換使用者就需要再新增一次白名單。</p>
<h2 id="參考資料">參考資料</h2>
<p><a href="https://www.taode.idv.tw/wordpress/?p=639">不變更 UAC 安全性，但執行程式時又不擾民的設定方式</a></p>
<hr>
]]></content:encoded>
    </item>
  </channel>
</rss>
