<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C# on Wenrong&#39;s Note</title>
    <link>https://wenrongdev.com/tags/c</link>
    <description>Recent content in C# on Wenrong&#39;s Note</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 12 Jun 2024 22:47:08 +0800</lastBuildDate>
    <atom:link href="https://wenrongdev.com/tags/c" rel="self" type="application/rss+xml" />
    <item>
      <title>C# Class 和 Struct 選擇</title>
      <link>https://wenrongdev.com/posts/c</link>
      <pubDate>Wed, 12 Jun 2024 22:47:08 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/c</guid>
      <description>C# Class 和 Struct 選擇</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>之前有講到 <a href=".../CSharpValueTypeReferenceType">C# Value Type、Reference Type 的差異</a>，現在來講一下 Class 和 Struct 選擇。</p>
<p>從上一篇的文章中可以知道 Class 是 Reference type，而 Struct 是 Value type。</p>
<h2 id="如何選擇">如何選擇</h2>
<p>根據<a href="https://learn.microsoft.com/zh-tw/dotnet/standard/design-guidelines/choosing-between-class-and-struct">在類別和結構之間選擇</a></p>
<blockquote>
<p>作為經驗規則，架構中大部分的類型應該為類別。 不過，在某些情況下，實值型別的特性會使它更適合使用結構。</p>
</blockquote>
<p>可以知道其實大部分時都是使用 Class，但在某些情況下使用 Struct 會比較適合。</p>
<h3 id="什麼時候使用-struct">什麼時候使用 Struct</h3>
<p><strong>如果類型的執行個體很小，且通常短期或通常內嵌在其他物件中，請考慮定義結構，而不是類別。</strong></p>
<p>除非類型具有下列所有特性，否則請「避免」定義結構：</p>
<ul>
<li>
<p>其以邏輯方式表示單一值，類似於基本類型 (int、double 等)。</p>
</li>
<li>
<p>其執行個體大小低於 16 個位元組。</p>
</li>
<li>
<p>類型為不可變，</p>
</li>
<li>
<p>而且不需要經常進行 Box。</p>
</li>
</ul>
<p><strong>在所有其他情況下，您應該將類型定義為類別。</strong></p>
<h2 id="參考連結">參考連結</h2>
<p><a href="https://hackmd.io/@SuFrank/H1coLlCaq">一起學 Class and Struct (C#)</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>C# Value Type、Reference Type 的差異</title>
      <link>https://wenrongdev.com/posts/csharpvaluetypereferencetype/</link>
      <pubDate>Tue, 11 Jun 2024 22:38:53 +0800</pubDate>
      <guid>https://wenrongdev.com/posts/csharpvaluetypereferencetype/</guid>
      <description>討論 C# Value Type、Reference Type 的差異</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>在公司讀書會與同事討論淺複製與深複製的差異和使用時機時，聊到 Reference Type、Value Type 的不同，但是要講淺複製與深複製之前要先講 Reference Type、Value Type 的差異。</p>
<h2 id="value-type-有哪些">Value Type 有哪些</h2>
<ol>
<li>
<p>整數的數字型別：sbyte、byte、short、ushort、int、uint、long、ulong、nint、nuint</p>
</li>
<li>
<p>浮點數值型別：float、double、decimal</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/numeric-conversions">內建數值轉換</a></p>
</li>
<li>
<p>bool</p>
</li>
<li>
<p>char</p>
</li>
<li>
<p>enum</p>
</li>
<li>
<p>struct</p>
</li>
<li>
<p>ref struct</p>
</li>
<li>
<p>tuples</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可為 Null 的值類型 (C# 參考)</a></p>
</li>
</ol>
<p>參考：<a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/value-types">實值類型 (C# 參考)</a></p>
<h2 id="reference-type-有哪些">Reference Type 有哪些</h2>
<ol>
<li>
<p>宣告參考型別：class、interface、delegate、record</p>
</li>
<li>
<p>內建參考類型：dynamic、object、string</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/builtin-types/nullable-reference-types">可為 Null 的參考型別</a></p>
</li>
<li>
<p>集合和陣列：集合（List、Dictionary）、陣列（int[]、string[]）</p>
</li>
</ol>
<p>參考：<a href="https://learn.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/reference-types">參考型別 (C# 參考)</a></p>
<h2 id="value-typereference-type-的差異">Value Type、Reference Type 的差異</h2>
<p>根據<a href="https://learn.microsoft.com/zh-tw/dotnet/standard/design-guidelines/choosing-between-class-and-struct">在類別和結構之間選擇</a>裡的一段話，可以分出 5 點差異。</p>
<h3 id="1-存放記憶體">1. 存放記憶體</h3>
<blockquote>
<p>參考型別會配置在回收的堆積和記憶體上，而實值型別則會配置在堆疊上，或內嵌在包含型別上，並在堆疊回溯時或其包含類型解除配置時解除配置。</p>
<p>因此，實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。</p>
</blockquote>
<p>可以得知主要是在存放的記憶體差異，因此 Value Type 配置和解除配置的成本比 Reference Type 成本更低。</p>
<p>實值型別的配置和解除配置的成本通常比參考型別的配置和解除配置的成本更低。</p>
<h3 id="2-陣列">2. 陣列</h3>
<blockquote>
<p>參考型別的陣列會以換行方式配置，這表示陣列元素只是位於堆積上之參考型別執行個體的參考。實值型別陣列會內嵌配置，這表示陣列元素是實值型別實際的執行個體。</p>
<p>因此，實值型別陣列的配置和解除配置的成本會遠比參考型別陣列的配置和解除配置的成本來得低。此外，在大部分情況下，實值型別陣列會呈現較佳的參考位置。</p>
</blockquote>
<p>Value Type 陣列的配置和解除配置成本較低，且通常在記憶體存取表現上優於 Reference Type 陣列。然而，Reference Type 陣列在處理複雜的物件或需要物件參考的情境中仍有其必要性。</p>
<h3 id="3-記憶體使用量">3. 記憶體使用量</h3>
<blockquote>
<p>強制轉型為參考型別或其實作的其中一個介面時，實值型別會進行 Boxed。 當強制轉型回實值型別時，它們會進行 Unboxed。</p>
<p>因為 Box 是配置在堆積上且被回收記憶體的物件，所以過多 Boxing 和 unboxing 可能會對堆積、記憶體回收行程，以及最終是應用程式的效能造成負面影響。</p>
</blockquote>
<p>強制轉型為 Reference Type 時，Value Type 會進行 Boxed。 當強制轉型回實值型別時會進行 Unboxed，過多的 Boxed 和 Unboxed 會增加垃圾回收（GC）的負擔，從而影響應用程式效能。</p>
<h3 id="4-複製參考">4. 複製參考</h3>
<blockquote>
<p>參考型別指派會複製參考，而實值型別指派則會複製整個值。 因此，大型參考型別的指派成本比大型實值型別的指派成本更低。</p>
</blockquote>
<h3 id="5-傳遞方式">5. 傳遞方式</h3>
<blockquote>
<p>參考型別會以傳址方式傳遞，而實值型別則是以傳值方式傳遞。對參考型別的執行個體所做的變更會影響所有指向執行個體的參考。實值型別執行個體會在以傳值方式傳遞時複製。變更實值型別的執行個體時，它必然不會影響其任何複本。</p>
<p>由於不會由使用者明確建立複本，而是會在傳回引數或傳回值時隱含建立，因此可以變更的實值型別可能會對許多使用者造成混淆。 因此，實值型別應該為不可變。</p>
</blockquote>
<p>由於 Value Type 在傳遞過程中會複製，變更複本時不會影響原始值，這有時會讓使用者感到困惑，因為預期的變更並未反映在原始變數上。</p>
<p>為了避免這種混淆，Value Type 通常應設計為不可變（immutable）。不可變的 Value Type 一旦創建，其狀態就無法改變，這樣可以確保每個複本都是一致且獨立的。</p>
<ul>
<li>Reference Type</li>
</ul>
<p>傳遞物件的記憶體地址。因此，對該物件所做的變更會影響所有持有該物件地址的參考。</p>
<p>當 Reference Type 的物件進行變更時，因為所有指向該物件的參考都是同一個實例，所有持有該參考的變數都會受到變更影響。</p>
<ul>
<li>Value Type</li>
</ul>
<p>會複製該值並將複本傳遞給目標位置。因此，對複本的變更不會影響原始值。</p>
<p>當傳遞 Value Type 並對其進行變更時，因為是對複本進行操作，原始實例不會受到任何影響。這意味著每個複本都是獨立的。</p>
<h2 id="參考連結">參考連結</h2>
<p><a href="https://hackmd.io/@SuFrank/H1coLlCaq">一起學 Class and Struct</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Whitelist for Windows UAC</title>
      <link>https://wenrongdev.com/posts/whitelist-for-windows-uac/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      <guid>https://wenrongdev.com/posts/whitelist-for-windows-uac/</guid>
      <description>為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。</description>
      <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>因為某些程式開啟時，會跳出需要系統管理員（Administrator）權限執行程式，也導致了只要是ㄧ般使用者每次開啟時都需要輸入系統管理員密碼來執行。為了ㄧ般使用者的權限問題也不能關閉 Windows UAC。 也不可能修改一般使用者的權限，所以需要讓 Windows UAC 加入此程式為白名單，這樣就不會每次都會跳出權限要求。</p>
<h2 id="已知限制條件">已知限制條件</h2>
<ol>
<li>程式必須以 Administrator 執行</li>
<li>一般使用者可以執行</li>
<li>不可完全關閉 Windows UAC</li>
</ol>
<h2 id="解決方式">解決方式</h2>
<p>根據<a href="https://www.taode.idv.tw/wordpress/?p=639">不變更 UAC 安全性，但執行程式時又不擾民的設定方式</a>，可以在 Windows Regedit 新增白名單。</p>
<ol>
<li>Win+R 輸入 regedit 執行</li>
<li>根據此路徑尋找 <code>HKEY_CURRENT_USERS\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers</code></li>
<li>右鍵新增字串值，名稱為程式（exe）路徑、資料為<code>~ RunAsInvoker</code></li>
</ol>
<h2 id="c-解決方式">C# 解決方式</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RegEditWhiteList</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> keyName { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> root = <span style="color:#e6db74">@&#34;Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> keyValue = <span style="color:#e6db74">&#34;~ RunAsInvoker&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> RegEditWhiteList(<span style="color:#66d9ef">string</span> keyName)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.keyName = keyName;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SendRegedit()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        RegistryKey key = Registry.CurrentUser.OpenSubKey(root, <span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        key.SetValue(keyName, keyValue,RegistryValueKind.String);
</span></span><span style="display:flex;"><span>        key.Close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="githubrepo"><a href="https://github.com/Wenrong274/UACWhitelist">GitHub</a></h2>
<h3 id="使用方式">使用方式</h3>
<p>因為修改註冊碼是修正當前使用者的註冊碼，因此只要換使用者就需要再新增一次白名單。</p>
<h2 id="參考資料">參考資料</h2>
<p><a href="https://www.taode.idv.tw/wordpress/?p=639">不變更 UAC 安全性，但執行程式時又不擾民的設定方式</a></p>
<hr>
]]></content:encoded>
    </item>
  </channel>
</rss>
