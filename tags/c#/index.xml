<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C# on Wenrong Nexus</title>
    <link>https://wenrong-nexus.com/tags/c</link>
    <description>Recent content in C# on Wenrong Nexus</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 28 Aug 2024 00:19:53 +0800</lastBuildDate>
    <atom:link href="https://wenrong-nexus.com/tags/c" rel="self" type="application/rss+xml" />
    <item>
      <title>Effective C# 做法 07-10</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme07-10/</link>
      <pubDate>Wed, 28 Aug 2024 00:19:53 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme07-10/</guid>
      <description>Effective C# 做法  07-10 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-07">做法 07</h2>
<p><code>以 delegate 表示 callback</code></p>
<p>可以利用 delegate 回傳 bool 當判斷或者是回傳類別等功能降低城市耦合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span>List&lt;<span style="color:#66d9ef">int</span>&gt; numbers = Enumerable.Range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>).ToList();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> oddNumbers = numbers.Find(x =&gt; x % <span style="color:#ae81ff">2</span> == <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> test = numbers.TrueForAll(x =&gt; x &lt; <span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>numbers.RemoveAll(x =&gt; x % <span style="color:#ae81ff">2</span> == <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>numbers.ForEach(x =&gt; Console.WriteLine(x));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LengthyOperation2(Func&lt;<span style="color:#66d9ef">bool</span>&gt; pred)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> bContinue = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> cl <span style="color:#66d9ef">in</span> container)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cl.DoLengthyOperation();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (Func&lt;<span style="color:#66d9ef">bool</span>&gt; pr <span style="color:#66d9ef">in</span> pred.GetInvocationList())
</span></span><span style="display:flex;"><span>                bContinue &amp;= pr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (!bContinue) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="做法-08">做法 08</h2>
<p>`對事件叫用使用空條件運算子</p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RaiseUpdate()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    counter++;
</span></span><span style="display:flex;"><span>    Updated?.Invoke(<span style="color:#66d9ef">this</span>, counter);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="做法-09">做法 09</h2>
<p><code>減少 boxing 與 unboxing</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> o = i; <span style="color:#75715e">/// box</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(o.ToString()); <span style="color:#75715e">/// 25</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> fp = <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> fo = fp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ip = (<span style="color:#66d9ef">int</span>)fo; <span style="color:#75715e">/// unbox</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(ip.ToString()); <span style="color:#75715e">/// 5</span>
</span></span></code></pre></div><blockquote>
<p>實值類型可變轉換成 System.Object 或任何界面參考。這些轉換隱含的發生，使得尋找它們變得更為複雜。
boxing 與 unboxing 操作會在你預料之外的複製拷貝，這導致 bug。以多型方式處理實值類型也有效能成本。</p>
</blockquote>
<p>參考類型轉換為 System.Object 或介面時的行為確實不同：</p>
<ol>
<li>參考類型轉換:
<ul>
<li>參考類型本來就是從 System.Object 繼承的，所以轉換為 System.Object 或實現的介面時不需要 boxing。</li>
<li>這種轉換只是改變了引用的類型，不會創建新的對象或複製數據。</li>
</ul>
</li>
<li>效能影響:
<ul>
<li>參考類型轉換為 System.Object 或介面基本上沒有額外的效能成本。</li>
<li>不會發生像實值類型那樣的額外記憶體分配或數據複製。</li>
</ul>
</li>
<li>多態性:
<ul>
<li>參考類型本來就支持多態，不需要額外的轉換步驟。</li>
</ul>
</li>
<li>潛在問題:
<ul>
<li>雖然參考類型不會遇到 boxing/unboxing 的問題，但可能會遇到其他問題，如意外的類型轉換或空引用。</li>
</ul>
</li>
</ol>
<h2 id="做法-10">做法 10</h2>
<p><code>只對基底類別更新使用 new 修飾詞</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">void</span> MagicMethon() { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>new 修飾詞必須小心使用。如果你不假思索的套用它，你會在你的物件中產生模糊的方法呼叫。這是發生在升級你的基底類別導致與你的類別衝突的特殊情況。就算在這種情況下，使用前還是要仔細思考。更重要的是，其他情況不要使用它。</p>
</blockquote>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 04-06</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme04-06/</link>
      <pubDate>Thu, 22 Aug 2024 21:28:59 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme04-06/</guid>
      <description>Effective C# 做法 04-06 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-04">做法 04</h2>
<p><code>以內插字串取代 string.Format()</code></p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">string</span> name = <span style="color:#e6db74">&#34;test&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> height = <span style="color:#ae81ff">180</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> age = <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str = <span style="color:#e6db74">$&#34;userName: {name}, age: {age}, height: {height}&#34;</span>;
</span></span></code></pre></div><h3 id="1-為什麼-mathpi-不寫-tostring-會造成-box-呢">1. 為什麼 Math.PI 不寫 ToString 會造成 box 呢?</h3>
<p>當需要調用 ToString() 方法時，如果我們沒有顯式調用，編譯器會嘗試使用 Object.ToString()。但是，為了使用 Object 上的方法，值類型必須先轉換為 Object，這就導致了裝箱。</p>
<h2 id="做法-05">做法 05</h2>
<p><code>對文化特定字串偏好 FormattableString</code></p>
<p>推薦使用 <code>FormattableString</code>，不會因為當地時間顯示或者數字的顯示有所差異。double 的小數點會是＂.＂；如果再歐洲會是顯示＂,＂。</p>
<h2 id="做法-06">做法 06</h2>
<p><code>避免字串型別 API</code></p>
<p>使用 <code>nameof</code> 運算子時，任何對於屬性名稱的改變都會正確的反應在用於事件參數的字串中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> name; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> != name)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            name = <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>            PropertyChanged?.Invoke(<span style="color:#66d9ef">this</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> PropertyChangedEventArgs(nameof(Name)));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 01-03</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme01-03/</link>
      <pubDate>Sat, 17 Aug 2024 23:09:29 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme01-03/</guid>
      <description>Effective C# 做法 01-03 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-01">做法 01</h2>
<p><code>偏好隱含型別的區域變數</code></p>
<p>參考書籍提到的最後一段</p>
<blockquote>
<p>簡單說，除非開者（包括以後的你）必須看到型別宣告才能理解程式，否則就使用 var 宣告區域變數。這個做法的標題是＂偏好＂而不是＂總是＂。我建議明確的宣告所有數值型別（int、float、double 與其他）而不要使用 var 宣告。其他東西就是用 var。多打幾個字 - 明確的宣告型別 - 不會提升行別安全或改善可讀性。如果挑錯宣告型別，你可能會造成編譯器本來能夠避免的低效率。</p>
</blockquote>
<h2 id="做法-02">做法 02</h2>
<p><code>偏好 readonly 而非 const</code></p>
<blockquote>
<p>必須在編譯期確定的值必須使用 const：屬性參數、switch case 標籤與 enum 定義，以及少數部會在版本間變化的數值。其餘狀況則傾向以 readonly 常數提升彈性。</p>
</blockquote>
<h3 id="1-const-使用建議">1. const 使用建議</h3>
<ul>
<li>對於在編譯時就能確定且永不改變的值</li>
<li>適用於基本數據類型（int、float、bool 等）和字符串</li>
<li>效能略優於 readonly，因為它是編譯時常量</li>
</ul>
<h3 id="2-readonly-使用建議">2. readonly 使用建議</h3>
<ul>
<li>對於運行時才能確定值的情況</li>
<li>可用於任何數據類型，包括引用類型和複雜類型</li>
<li>允許在構造函數中賦值</li>
</ul>
<h3 id="選擇指南">選擇指南</h3>
<ul>
<li>如果值在編譯時就能確定，且是基本類型或字符串，優先使用 const。</li>
<li>如果是引用類型或需要在運行時計算的值，使用 readonly。</li>
<li>如果需要在不同的構造函數中賦予不同的值，使用 readonly。</li>
<li>對於靜態成員，如果符合 const 的條件，優先使用 const；否則使用 static readonly。</li>
</ul>
<h2 id="做法-03">做法 03</h2>
<p><code>偏好 is 或 as 運算子而非型別轉換</code></p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">object</span> o = <span style="color:#66d9ef">new</span> MyType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// 不推薦</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> t = (MyType)o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// 推薦</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (o <span style="color:#66d9ef">is</span> MyType myType)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    myType.Do();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// do samething ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
  </channel>
</rss>
