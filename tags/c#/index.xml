<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C# on Wenrong Nexus</title>
    <link>https://wenrong-nexus.com/tags/c</link>
    <description>Recent content in C# on Wenrong Nexus</description>
    <generator>Hugo -- 0.124.1</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 28 Sep 2024 01:48:09 +0800</lastBuildDate>
    <atom:link href="https://wenrong-nexus.com/tags/c" rel="self" type="application/rss+xml" />
    <item>
      <title>Effective C# 做法 18-19</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme18-19/</link>
      <pubDate>Sat, 28 Sep 2024 01:48:09 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme18-19/</guid>
      <description>Effective C# 做法 18-19 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-18">做法 18</h2>
<p>`使用泛型 &amp; 定義最少與足夠的約束</p>
<h3 id="使用泛型">使用泛型</h3>
<ul>
<li>
<p>為什麼這三組執行期都共用相同的程式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span>List&lt;<span style="color:#66d9ef">string</span>&gt; strings = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>List&lt;Stream&gt; streams=newList&lt;Stream&gt;();
</span></span><span style="display:flex;"><span>List&lt;MyClassType&gt; myClassTypes=newList&lt;MyClassType&gt;();
</span></span></code></pre></div></li>
</ul>
<p>JIT 編譯器識別出這些類型都是引用類型，因此可以使用相同的機器代碼。</p>
<ul>
<li>
<p>為什麼這三組有不同的機械碼?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span>List&lt;<span style="color:#66d9ef">double</span>&gt; doubles = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">double</span>&gt;();
</span></span><span style="display:flex;"><span>List&lt;<span style="color:#66d9ef">int</span>&gt; ints = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">int</span>&gt;();
</span></span><span style="display:flex;"><span>List&lt;MyStruct&gt; myStructs = <span style="color:#66d9ef">new</span> List&lt;MyStruct&gt;();
</span></span></code></pre></div><p>CLR 為每種值類型參數生成特定的代碼，以優化性能和類型安全性。</p>
</li>
</ul>
<h4 id="1-泛型類別使用-default">1. 泛型類別使用 default()</h4>
<p>在講到泛型類別使用 default() 的方法寫時，需要把 T 改成 T?，因為 Value Type 的 Default = 0，而 Reference Type 是沒有 Default，回傳的結果會是 null。
需要告訴使用者可能會回傳 null 建議還是要回傳 T?，也提高程式碼閱讀性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> T? FirstOrDefault&lt;T&gt;(<span style="color:#66d9ef">this</span> IEnumerable&lt;T&gt; source, Predicate&lt;T&gt; predicate)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> item <span style="color:#66d9ef">in</span> source)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (predicate(item))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> item;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-少了-null-確認">2. 少了 null 確認</h4>
<p>原本課本的判斷，少了 null 確認</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> AreEqual(T left, T right) =&gt;	left.Equals(right);
</span></span></code></pre></div><p>可以改這種寫法，多了做法 03 的寫法，用來判斷 null。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> AreEqual&lt;T&gt;(T left, T right)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (left <span style="color:#66d9ef">is</span> T qu)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> qu.Equals(right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> right == <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="3-使用-t">3. 使用 T?</h4>
<p>使用 T? 明確表示 factory 方法可能返回 null。這增加了代碼的可讀性和意圖的清晰度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span>MyClass obj1 = Factory(() =&gt; <span style="color:#66d9ef">new</span> MyClass { Name = <span style="color:#e6db74">&#34;Object 1&#34;</span> });
</span></span><span style="display:flex;"><span>Console.WriteLine(obj1.Name); <span style="color:#75715e">// 輸出: Object 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用返回 null 的工廠方法</span>
</span></span><span style="display:flex;"><span>MyClass obj2 = Factory&lt;MyClass&gt;(() =&gt; <span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>Console.WriteLine(obj2.Name); <span style="color:#75715e">// 輸出: Default Name</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> T FactoryFunc&lt;T&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> T Factory&lt;T&gt;(FactoryFunc&lt;T?&gt; factory) <span style="color:#66d9ef">where</span> T : <span style="color:#66d9ef">new</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    T? resultVal = factory();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (resultVal == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        resultVal = <span style="color:#66d9ef">new</span> T();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> resultVal;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4-為什麼要盡量避免約束-newstructclass">4. 為什麼要盡量避免約束 new()、struct、class</h4>
<h4 id="new-約束">new() 約束</h4>
<p>優點：</p>
<ul>
<li>保證類型有無參數構造函數。
缺點：</li>
<li>限制了類型的靈活性，排除了沒有公共無參數構造函數的類型。</li>
<li>可能導致不必要的對象創建，影響性能。</li>
<li>難以進行單元測試，因為無法輕易模擬或替換對象。</li>
</ul>
<h4 id="struct-約束">struct 約束</h4>
<p>優點：</p>
<ul>
<li>確保類型是值類型。</li>
</ul>
<p>缺點：</p>
<ul>
<li>過度限制了類型，排除了可能同樣適用的引用類型。</li>
<li>可能導致不必要的裝箱和拆箱操作。</li>
<li>限制了代碼的重用性和靈活性。</li>
</ul>
<h3 id="class-約束">class 約束</h3>
<p>優點：</p>
<ul>
<li>確保類型是引用類型。</li>
</ul>
<p>缺點：</p>
<ul>
<li>排除了可能同樣適用的值類型。</li>
<li>限制了代碼的通用性。</li>
<li>可能導致不必要的堆分配。</li>
</ul>
<p>一般建議：</p>
<ol>
<li>
<p>優先使用接口約束：接口約束更靈活，能同時適用於值類型和引用類型。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GenericClass</span>&lt;T&gt; <span style="color:#66d9ef">where</span> T : IComparable&lt;T&gt;
</span></span></code></pre></div></li>
<li>
<p>基於行為而非類型種類進行約束：關注類型能做什麼，而不是類型是什麼。</p>
</li>
<li>
<p>考慮使用泛型約束的組合：在必要時，可以組合多個接口約束來精確定義所需的功能。</p>
</li>
<li>
<p>使用 default 關鍵字：代替 new()，使用 default(T) 來獲取類型的默認值。</p>
</li>
<li>
<p>設計靈活的 API：避免過度約束，以增加代碼的重用性和適應性。</p>
</li>
<li>
<p>考慮性能影響：某些約束（如 struct）可能導致意外的性能問題。</p>
</li>
</ol>
<h3 id="總結">總結</h3>
<p>避免使用 new()、 struct 和 class 約束主要是為了提高代碼的靈活性、可重用性和可測試性。通過使用更通用的約束（如接口），我們可以編寫出更加靈活和強大的泛型代碼，適用於更廣泛的類型。</p>
<h2 id="做法-19">做法 19</h2>
<p>使用執行期型別檢查特化泛型演算法
實作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReverseEnumerable</span>&lt;T&gt; : IEnumerable&lt;T&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReverseEnumerator</span> : IEnumerator&lt;T&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> currentIndex = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> IList&lt;T&gt; collection;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> T Current =&gt; collection[currentIndex];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">object</span> IEnumerator.Current =&gt; Current;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> ReverseEnumerator(List&lt;T&gt; collection) : <span style="color:#66d9ef">this</span>(collection.ToArray())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> ReverseEnumerator(IList&lt;T&gt; collection)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            currentIndex = collection.Count;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">this</span>.collection = collection;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Dispose()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> MoveNext()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> --currentIndex &gt;= <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Reset()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            currentIndex = collection.Count;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">sealed</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReverseStringEnumerator</span> : IEnumerator&lt;<span style="color:#66d9ef">char</span>&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> sourceSequence;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> currentIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> ReverseStringEnumerator(<span style="color:#66d9ef">string</span> source)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            sourceSequence = source;
</span></span><span style="display:flex;"><span>            currentIndex = source.Length;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">char</span> Current =&gt; sourceSequence[currentIndex];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">object</span> IEnumerator.Current =&gt; sourceSequence[currentIndex];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Dispose() { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> MoveNext()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> --currentIndex &gt;= <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Reset()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            currentIndex = sourceSequence.Length;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> IEnumerable&lt;T&gt;? sourceSequence;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> IList&lt;T&gt;? originalSequence;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ReverseEnumerable(IEnumerable&lt;T&gt; source)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (source <span style="color:#66d9ef">is</span> ReverseEnumerable&lt;T&gt; reverseEnumerable)
</span></span><span style="display:flex;"><span>            sourceSequence = reverseEnumerable;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (source <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">string</span> str)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            originalSequence = str.ToArray() <span style="color:#66d9ef">as</span> IList&lt;T&gt;;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            originalSequence = source <span style="color:#66d9ef">as</span> IList&lt;T&gt;;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ReverseEnumerable(IList&lt;T&gt; source) : <span style="color:#66d9ef">this</span>((IEnumerable&lt;T&gt;)source)
</span></span><span style="display:flex;"><span>    { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> IEnumerator&lt;T&gt; GetEnumerator()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sourceSequence <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">string</span> str)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ReverseStringEnumerator(str) <span style="color:#66d9ef">as</span> IEnumerator&lt;T&gt;;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (originalSequence == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (sourceSequence <span style="color:#66d9ef">is</span> ICollection&lt;T&gt; source)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                originalSequence = <span style="color:#66d9ef">new</span> List&lt;T&gt;(source.Count);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                originalSequence = <span style="color:#66d9ef">new</span> List&lt;T&gt;(sourceSequence);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ReverseEnumerator(originalSequence);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IEnumerator IEnumerable.GetEnumerator()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> GetEnumerator();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StringEnumerable()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> str = <span style="color:#e6db74">&#34;Hello, World!&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> reverseEnumerable = <span style="color:#66d9ef">new</span> ReverseEnumerable&lt;<span style="color:#66d9ef">char</span>&gt;(str);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">char</span> c <span style="color:#66d9ef">in</span> reverseEnumerable)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.Write(c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// !dlroW ,olleH</span>
</span></span><span style="display:flex;"><span>    Console.WriteLine();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> ListEnumerable()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    List&lt;<span style="color:#66d9ef">int</span>&gt; list = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">int</span>&gt;() { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> reverseEnumerable = <span style="color:#66d9ef">new</span> ReverseEnumerable&lt;<span style="color:#66d9ef">int</span>&gt;(list);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">int</span> i <span style="color:#66d9ef">in</span> reverseEnumerable)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.Write(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 76543210</span>
</span></span><span style="display:flex;"><span>    Console.WriteLine();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 16-17</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme16-17/</link>
      <pubDate>Sun, 22 Sep 2024 22:17:41 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme16-17/</guid>
      <description>Effective C# 做法 16-17 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-16">做法 16</h2>
<p><code>絕不在建構元中呼叫虛擬函式</code></p>
<p>本章節有提到 Static Code Analyzer 工具，可以利用這些工具避免建構子中呼叫虛擬函式。
工具分別有</p>
<ul>
<li>Visual Studio</li>
<li>JetBrains Rider</li>
<li>Visual Studio + ReSharper
針對 Unity 的 Static Code Analyzer 只能用這些工具</li>
<li>JetBrains Rider</li>
<li>Visual Studio + ReSharper</li>
<li>Unity + Roslyn</li>
</ul>
<h2 id="做法-17">做法 17</h2>
<p>`實作標準 Dispose 模式</p>
<h3 id="unmanaged-型別">Unmanaged 型別</h3>
<ul>
<li>
<p>sbyte、byte、short、ushort、int、uint、long、ulong、nint、nuint、char、float、double、decimal 或 bool</p>
</li>
<li>
<p>任何 enum 型別</p>
</li>
<li>
<p>任何指標型別</p>
</li>
<li>
<p>Tuple 其成員皆為非受控型別</p>
</li>
<li>
<p>任何只包含非受控型別欄位的使用者定義結構型別。</p>
</li>
</ul>
<h3 id="unmanaged-資源">Unmanaged 資源</h3>
<ul>
<li>是否繼承 IDisposable</li>
<li>檢查類別文件</li>
<li>分析類別用途和功能</li>
<li>看原始碼</li>
<li>利用反射，查看有沒有 Finalizer，如 sadehandle</li>
</ul>
<h3 id="需要實現-idisposable-的類別">需要實現 IDisposable 的類別</h3>
<ul>
<li>有 Unmanaged 資源</li>
<li>包含 IDisposable 成員</li>
<li>大型物件或耗資源的類別，如大型資料庫、影片、音效等</li>
<li>長生命週期物件，如連線功能、控制器等</li>
<li>自訂義資源管理類別</li>
</ul>
<h3 id="不需要實現-idisposable-的類別">不需要實現 IDisposable 的類別</h3>
<ul>
<li>純數據類資料</li>
<li>無狀態工具類</li>
<li>短生命週期的簡單物件</li>
<li>不管理任何資源的類別
不是每的類別都蓄要繼承 IDisposable 。僅當你的類別管理 Unmanaged 資源或者包含實現 IDisposable 介面的成員，才考慮繼承 IDisposable。</li>
</ul>
<h3 id="1除非你的類別直接持有-unmanaged-資源否則你不應該實作-finalizer">1.除非你的類別直接持有 Unmanaged 資源，否則你不應該實作 finalizer。</h3>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/standard/garbage-collection/implementing-dispose">實作 Dispose 方法</a></p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 14-15</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme14-15/</link>
      <pubDate>Sat, 14 Sep 2024 23:57:56 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme14-15/</guid>
      <description>Effective C# 做法 14-15 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-14">做法 14</h2>
<p><code>減少重複的初始化邏輯</code></p>
<h3 id="1-建構子初始化程序讓一個建構子呼叫其他的建構子">1. 建構子初始化程序讓一個建構子呼叫其他的建構子。</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> List&lt;<span style="color:#66d9ef">string</span>&gt; coll;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> MyClass() : <span style="color:#66d9ef">this</span>(<span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">string</span>.Empty) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> MyClass(<span style="color:#66d9ef">int</span> count, <span style="color:#66d9ef">string</span> name)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        coll = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt;(count);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.name = name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-選擇預設參數與">2. 選擇預設參數與</h3>
<p>選擇預設參數與使用多個建構子多載之間需要權衡考量，建議是不超過 3 個，超過時可以考慮使用一個類別當初始化類別使用。一般來說應該偏好預設值而非多載建構子。</p>
<h3 id="3-繼承類別不能修改父類別中宣告為-readonly-的欄位">3. 繼承類別不能修改父類別中宣告為 readonly 的欄位。</h3>
<p>readonly 欄位只能在宣告時或在定義該欄位的類別建構子中賦值。</p>
<h2 id="做法-15">做法 15</h2>
<p><code>避免建構不必要的物件</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPaint(PaintEventArgs e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 劣</span>
</span></span><span style="display:flex;"><span>    using(Font myFont = <span style="color:#66d9ef">new</span> Font(<span style="color:#e6db74">&#34;Arial&#34;</span>, <span style="color:#ae81ff">12.0f</span>)){
</span></span><span style="display:flex;"><span>        e.Graphics.DrawString(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>, myFont, Brushes.Black, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>推薦方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> Font myFont = <span style="color:#66d9ef">new</span> Font(<span style="color:#e6db74">&#34;Arial&#34;</span>, <span style="color:#ae81ff">12.0f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> OnPaint(PaintEventArgs e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e.Graphics.DrawString(<span style="color:#e6db74">&#34;Hello, World!&#34;</span>, myFont, Brushes.Black, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="1-區域變數的選擇">1. 區域變數的選擇</h3>
<p>在區域變數是參考型別（實值類型就沒關係），且會在經常被呼叫的程序中使用時將它提升至成員變數。</p>
<h3 id="2-string-不可變的原因">2. string 不可變的原因</h3>
<ol>
<li>安全性：敏感資訊不會因此被修改。</li>
<li>執行緒安全：不可變性是天然的執行緒安全。</li>
<li>hash 一致：字典的 key 相同內容、相同的位址。</li>
<li>字串池：.NET 優化</li>
<li>性能優化：編譯器和運行可優化字串。</li>
<li>API 設計簡化</li>
</ol>
<h3 id="3建構不可變的可變-builder-類別">3.建構不可變的可變 builder 類別</h3>
<p>可以參考設計模式中的建造者模式。</p>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 11-13</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme11-13/</link>
      <pubDate>Sat, 07 Sep 2024 13:54:06 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme11-13/</guid>
      <description>Effective C# 做法 11-13 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-11">做法 11</h2>
<p><code>認識 .NET 資源管理</code></p>
<h3 id="1-簡易圖示記憶體區塊的關聯圖">1. 簡易圖示記憶體區塊的關聯圖</h3>
<p><img loading="lazy" src="https://i.imgur.com/dfX2Obh.png" alt="img_1"  />
</p>
<h3 id="2-記憶體排列物件的放置位址">2. 記憶體排列物件的放置位址</h3>
<p><img loading="lazy" src="https://i.imgur.com/FOmH0z0.png" alt="img_2"  />
</p>
<p>呼叫 GC 後，記憶體位置改變了，這就是記憶體回收的概念</p>
<p><img loading="lazy" src="https://i.imgur.com/JNXcMs0.png" alt="img_3"  />
</p>
<h3 id="3-記憶體層代">3. 記憶體層代</h3>
<ul>
<li>
<p>層代 0</p>
<p>最新的層代而且包含存留較短的物件。大部分物件都會在層代 0 的記憶體回收，而且不會存留至下一個層代。記憶體回收從第 0 個層代開始。</p>
</li>
<li>
<p>層代 1</p>
<p>這個層代包含存留較短的物件，且當做較短與較長物件的緩衝區。層代 0 回收後，將壓縮可取得的物件，升階至層代 1。</p>
<p>層代 0 已滿時，記憶體會執行回收。如果層代 0 回收沒有足夠的記憶體，才會執行層代 1 回收，再執行層代 2 回收，層代 1 回收之後有存留的物件，會提升至層代 2。</p>
</li>
<li>
<p>層代 2</p>
<p>存留較長的物件。層代 2 回收存留的物件還是回留在層代 2。</p>
<p>最後結論就是，假如不在一開始就把物件釋放掉，最後存留至層代 1、2 時，要回收物件的時間就會越來越久，造成的記憶體效率不佳，所以要手動釋放掉物件。</p>
</li>
</ul>
<p><a href="https://learn.microsoft.com/zh-tw/dotnet/standard/garbage-collection/fundamentals">記憶體回收的基本概念</a></p>
<h3 id="4-使用-dispose-釋放資源而不是-finalizer">4. 使用 Dispose 釋放資源，而不是 Finalizer</h3>
<h2 id="做法-12">做法 12</h2>
<p><code>偏好成員初始化程序而非指派陳述</code></p>
<h3 id="為什麼-initobj-會導致-boxunbox">為什麼 initobj 會導致 box、unbox？</h3>
<p>initobj 指令用於將值類型的變量初始化為其默認值，因此 initobj 不會導致 boxing 或 unboxing。
使用 initobj 時，是直接記憶體操作，不涉及對象的創建或類型的轉換。</p>
<p>推薦用法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> List&lt;<span style="color:#66d9ef">string</span>&gt; labels = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="做法-13">做法 13</h2>
<p><code>對靜態類別成員進行適當的初始化</code></p>
<p>Singleton 初始化具有複雜的邏輯，可以在 <code>static</code> 建構子中寫。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MySingleton</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> MySingleton instance = <span style="color:#66d9ef">new</span> MySingleton();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> MySingleton Instance =&gt; instance;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> MySingleton() { }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MySingleton2</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> MySingleton2 instance;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> MySingleton2()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        instance = <span style="color:#66d9ef">new</span> MySingleton2();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> MySingleton2 Instance =&gt; instance;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> MySingleton2() { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 07-10</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme07-10/</link>
      <pubDate>Wed, 28 Aug 2024 00:19:53 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme07-10/</guid>
      <description>Effective C# 做法 07-10 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-07">做法 07</h2>
<p><code>以 delegate 表示 callback</code></p>
<p>可以利用 delegate 回傳 bool 當判斷或者是回傳類別等功能降低城市耦合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span>List&lt;<span style="color:#66d9ef">int</span>&gt; numbers = Enumerable.Range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>).ToList();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> oddNumbers = numbers.Find(x =&gt; x % <span style="color:#ae81ff">2</span> == <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> test = numbers.TrueForAll(x =&gt; x &lt; <span style="color:#ae81ff">50</span>);
</span></span><span style="display:flex;"><span>numbers.RemoveAll(x =&gt; x % <span style="color:#ae81ff">2</span> == <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>numbers.ForEach(x =&gt; Console.WriteLine(x));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LengthyOperation2(Func&lt;<span style="color:#66d9ef">bool</span>&gt; pred)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> bContinue = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> cl <span style="color:#66d9ef">in</span> container)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        cl.DoLengthyOperation();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (Func&lt;<span style="color:#66d9ef">bool</span>&gt; pr <span style="color:#66d9ef">in</span> pred.GetInvocationList())
</span></span><span style="display:flex;"><span>                bContinue &amp;= pr();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (!bContinue) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="做法-08">做法 08</h2>
<p><code>對事件叫用使用空條件運算子</code></p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RaiseUpdate()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    counter++;
</span></span><span style="display:flex;"><span>    Updated?.Invoke(<span style="color:#66d9ef">this</span>, counter);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="做法-09">做法 09</h2>
<p><code>減少 boxing 與 unboxing</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> o = i; <span style="color:#75715e">/// box</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(o.ToString()); <span style="color:#75715e">/// 25</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> fp = <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">object</span> fo = fp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ip = (<span style="color:#66d9ef">int</span>)fo; <span style="color:#75715e">/// unbox</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(ip.ToString()); <span style="color:#75715e">/// 5</span>
</span></span></code></pre></div><blockquote>
<p>實值類型可變轉換成 System.Object 或任何界面參考。這些轉換隱含的發生，使得尋找它們變得更為複雜。
boxing 與 unboxing 操作會在你預料之外的複製拷貝，這導致 bug。以多型方式處理實值類型也有效能成本。</p>
</blockquote>
<p>參考類型轉換為 System.Object 或介面時的行為確實不同：</p>
<ol>
<li>參考類型轉換:
<ul>
<li>參考類型本來就是從 System.Object 繼承的，所以轉換為 System.Object 或實現的介面時不需要 boxing。</li>
<li>這種轉換只是改變了引用的類型，不會創建新的對象或複製數據。</li>
</ul>
</li>
<li>效能影響:
<ul>
<li>參考類型轉換為 System.Object 或介面基本上沒有額外的效能成本。</li>
<li>不會發生像實值類型那樣的額外記憶體分配或數據複製。</li>
</ul>
</li>
<li>多態性:
<ul>
<li>參考類型本來就支持多態，不需要額外的轉換步驟。</li>
</ul>
</li>
<li>潛在問題:
<ul>
<li>雖然參考類型不會遇到 boxing/unboxing 的問題，但可能會遇到其他問題，如意外的類型轉換或空引用。</li>
</ul>
</li>
</ol>
<h2 id="做法-10">做法 10</h2>
<p><code>只對基底類別更新使用 new 修飾詞</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">void</span> MagicMethod() { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>new 修飾詞必須小心使用。如果你不假思索的套用它，你會在你的物件中產生模糊的方法呼叫。這是發生在升級你的基底類別導致與你的類別衝突的特殊情況。就算在這種情況下，使用前還是要仔細思考。更重要的是，其他情況不要使用它。</p>
</blockquote>
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 04-06</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme04-06/</link>
      <pubDate>Thu, 22 Aug 2024 21:28:59 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme04-06/</guid>
      <description>Effective C# 做法 04-06 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-04">做法 04</h2>
<p><code>以內插字串取代 string.Format()</code></p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">string</span> name = <span style="color:#e6db74">&#34;test&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> height = <span style="color:#ae81ff">180</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> age = <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">string</span> str = <span style="color:#e6db74">$&#34;userName: {name}, age: {age}, height: {height}&#34;</span>;
</span></span></code></pre></div><h3 id="1-為什麼-mathpi-不寫-tostring-會造成-box-呢">1. 為什麼 Math.PI 不寫 ToString 會造成 box 呢?</h3>
<p>當需要調用 ToString() 方法時，如果我們沒有顯式調用，編譯器會嘗試使用 Object.ToString()。但是，為了使用 Object 上的方法，值類型必須先轉換為 Object，這就導致了裝箱。</p>
<h2 id="做法-05">做法 05</h2>
<p><code>對文化特定字串偏好 FormattableString</code></p>
<p>推薦使用 <code>FormattableString</code>，不會因為當地時間顯示或者數字的顯示有所差異。double 的小數點會是＂.＂；如果再歐洲會是顯示＂,＂。</p>
<h2 id="做法-06">做法 06</h2>
<p><code>避免字串型別 API</code></p>
<p>使用 <code>nameof</code> 運算子時，任何對於屬性名稱的改變都會正確的反應在用於事件參數的字串中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">get</span> { <span style="color:#66d9ef">return</span> name; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">set</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> != name)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            name = <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>            PropertyChanged?.Invoke(<span style="color:#66d9ef">this</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> PropertyChangedEventArgs(nameof(Name)));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
    <item>
      <title>Effective C# 做法 01-03</title>
      <link>https://wenrong-nexus.com/posts/effectivecsharpitme01-03/</link>
      <pubDate>Sat, 17 Aug 2024 23:09:29 +0800</pubDate>
      <guid>https://wenrong-nexus.com/posts/effectivecsharpitme01-03/</guid>
      <description>Effective C# 做法 01-03 心得</description>
      <content:encoded><![CDATA[<h2 id="做法-01">做法 01</h2>
<p><code>偏好隱含型別的區域變數</code></p>
<p>參考書籍提到的最後一段</p>
<blockquote>
<p>簡單說，除非開者（包括以後的你）必須看到型別宣告才能理解程式，否則就使用 var 宣告區域變數。這個做法的標題是＂偏好＂而不是＂總是＂。我建議明確的宣告所有數值型別（int、float、double 與其他）而不要使用 var 宣告。其他東西就是用 var。多打幾個字 - 明確的宣告型別 - 不會提升行別安全或改善可讀性。如果挑錯宣告型別，你可能會造成編譯器本來能夠避免的低效率。</p>
</blockquote>
<h2 id="做法-02">做法 02</h2>
<p><code>偏好 readonly 而非 const</code></p>
<blockquote>
<p>必須在編譯期確定的值必須使用 const：屬性參數、switch case 標籤與 enum 定義，以及少數部會在版本間變化的數值。其餘狀況則傾向以 readonly 常數提升彈性。</p>
</blockquote>
<h3 id="1-const-使用建議">1. const 使用建議</h3>
<ul>
<li>對於在編譯時就能確定且永不改變的值</li>
<li>適用於基本數據類型（int、float、bool 等）和字符串</li>
<li>效能略優於 readonly，因為它是編譯時常量</li>
</ul>
<h3 id="2-readonly-使用建議">2. readonly 使用建議</h3>
<ul>
<li>對於運行時才能確定值的情況</li>
<li>可用於任何數據類型，包括引用類型和複雜類型</li>
<li>允許在構造函數中賦值</li>
</ul>
<h3 id="選擇指南">選擇指南</h3>
<ul>
<li>如果值在編譯時就能確定，且是基本類型或字符串，優先使用 const。</li>
<li>如果是引用類型或需要在運行時計算的值，使用 readonly。</li>
<li>如果需要在不同的構造函數中賦予不同的值，使用 readonly。</li>
<li>對於靜態成員，如果符合 const 的條件，優先使用 const；否則使用 static readonly。</li>
</ul>
<h2 id="做法-03">做法 03</h2>
<p><code>偏好 is 或 as 運算子而非型別轉換</code></p>
<p>推薦這樣寫</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Csharp" data-lang="Csharp"><span style="display:flex;"><span><span style="color:#66d9ef">object</span> o = <span style="color:#66d9ef">new</span> MyType();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// 不推薦</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> t = (MyType)o;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// 推薦</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (o <span style="color:#66d9ef">is</span> MyType myType)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    myType.Do();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// do samething ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
]]></content:encoded>
    </item>
  </channel>
</rss>
